# Rank functions in MySQL

## Business Questions ?

* What are top-5 products sold in each state in USA

* What are top-10 Universities in the world

* What are top-10 heart surgeons in California

* Which beauty products did not sell well in New York

* What are the top-3 tennis players per country

* What are the top-10 products sold in Black Friday

* What are the Bottom-10 products sold in Black Friday


## Ranking functions answer these type of questions

	SQL ranking functions serve the purpose 
	of assigning a unique or non-unique rank 
	to each row within a result set, or within 
	specific partitions (groups) of a result set, 
	based on a defined ordering criterion. 
	
	These functions are crucial for various data 
	analysis and reporting tasks, allowing for the 
	identification of top performers, the creation 
	of leaderboards, or the categorization of data 
	based on relative position.


# Ranking Functions in Action

	1. RANK() 
	   with gaps
	
	2. DENSE_RANK()
	   no gaps
	
	3. ROW_NUMBER()
	   sequential numbers: 1, 2, 3, ...
	

  | score | `row_number()` |`rank()`| `dense_rank()` |
  |-------|----------------|--------|----------------|
  |  10   |  1             | 1      | 1              |
  |  11   |  2             | 2      | 2              |
  |  11   |  3             | 2      | 2              |
  |  11   |  4             | 2      | 2              |
  |  16   |  5             | 5      | 3              |
  |  20   |  6             | 6      | 4              |
  


## 1. `RANK():`

	Assigns a unique rank number to each distinct row 
	within a partition. If two or more rows have the same 
	value, they receive the same rank, but the next rank(s) 
	will skip numbers.

	For example, if two rows are tied for rank 1, the next 
	rank will be 3 (1, 1, 3).

## 2. `DENSE_RANK(): no gap`

	Similar to RANK(), but it does not skip ranks when 
	there are ties. If two rows have the same rank, 
	the next rank will be consecutive.

	For example, if two rows are tied for rank 1, 
	the next rank will be 2 (1, 1, 2).

## 3. `ROW_NUMBER():`

	Assigns a unique sequential integer to rows 
	within a partition. Unlike RANK() and DENSE_RANK(), 
	it does not account for ties; each row gets a unique 
	number regardless of duplicates.

## Syntax Simplified

	The syntax for using these functions is as follows:

		RANK() OVER (PARTITION BY column ORDER BY column)
		
		DENSE_RANK() OVER (PARTITION BY column ORDER BY column)
		
		ROW_NUMBER() OVER (PARTITION BY column ORDER BY column)


## Rank functions = Window functions


	Rank functions in MySQL are window functions 
	that allow you to assign a rank to each row 
	within a partition of a result set. 
	
	These functions are particularly useful for 
	performing calculations based on the order 
	of rows, such as finding the highest or lowest 
	values, and they can help you easily categorize 
	data without needing to create complex subqueries.


## Types of Rank Functions


### 1. `RANK()`:

	Assigns a unique rank number to each distinct 
	row within a partition. If two or more rows have 
	the same value, they receive the same rank, but 
	the next rank(s) will skip numbers.

	For example, if two rows are tied for rank 1, 
	the next rank will be 3 (1, 1, 3).


### 2. `DENSE_RANK()`:

	Similar to RANK(), but it does not skip ranks 
	when there are ties. If two rows have the same 
	rank, the next rank will be consecutive.

	For example, if two rows are tied for rank 1, 
	the next rank will be 2 (1, 1, 2).


### 3. `ROW_NUMBER()`:

	Assigns a unique sequential integer to rows 
	within a partition. Unlike `RANK()` and 
	`DENSE_RANK()`, it does not account for ties; 
	each row gets a unique number regardless of duplicates.

## Syntax

The syntax for using these functions is as follows:

```
   RANK() OVER (PARTITION BY column ORDER BY column)
   
   DENSE_RANK() OVER (PARTITION BY column ORDER BY column)
   
   ROW_NUMBER() OVER (PARTITION BY column ORDER BY column)
```

## Example:

Suppose you have a scores table with the following structure and data:

```sql
-- Create the scores table
CREATE TABLE scores (
    student_id INT,
    subject VARCHAR(50),
    score INT
);

-- Insert data into the scores table
INSERT INTO scores (student_id, subject, score) 
VALUES
(1, 'Math', 95),
(2, 'Math', 85),
(3, 'Math', 95),
(4, 'Math', 75),
(1, 'Science', 90),
(2, 'Science', 88),
(3, 'Science', 90);
```

### View Data

```
mysql> select * from scores;
+------------+---------+-------+
| student_id | subject | score |
+------------+---------+-------+
|          1 | Math    |    95 |
|          2 | Math    |    85 |
|          3 | Math    |    95 |
|          4 | Math    |    75 |
|          1 | Science |    90 |
|          2 | Science |    88 |
|          3 | Science |    90 |
+------------+---------+-------+
7 rows in set (0.00 sec)
```

## Query Example

	To assign ranks to students based on their scores 
	in each subject, you could use:

### NO PARTITION, ORDER BY DESC
```sql
SELECT 
    student_id,
    subject,
    score,
    RANK() OVER (ORDER BY score DESC) AS the_rank,
    DENSE_RANK() OVER (ORDER BY score DESC) AS the_dense_rank,
    ROW_NUMBER() OVER (ORDER BY score DESC) AS the_row_number
FROM 
    scores;
+------------+---------+-------+----------+----------------+----------------+
| student_id | subject | score | the_rank | the_dense_rank | the_row_number |
+------------+---------+-------+----------+----------------+----------------+
|          1 | Math    |    95 |        1 |              1 |              1 |
|          3 | Math    |    95 |        1 |              1 |              2 |
|          1 | Science |    90 |        3 |              2 |              3 |
|          3 | Science |    90 |        3 |              2 |              4 |
|          2 | Science |    88 |        5 |              3 |              5 |
|          2 | Math    |    85 |        6 |              4 |              6 |
|          4 | Math    |    75 |        7 |              5 |              7 |
+------------+---------+-------+----------+----------------+----------------+
7 rows in set (0.001 sec)
```

### NO PARTITION, ORDER BY ASC
```sql
SELECT 
    student_id,
    subject,
    score,
    RANK() OVER (ORDER BY score ASC) AS the_rank,
    DENSE_RANK() OVER (ORDER BY score ASC) AS the_dense_rank,
    ROW_NUMBER() OVER (ORDER BY score ASC) AS the_row_number
FROM 
    scores;
```

## Top-1 Per Subject

```sql
SELECT 
    subject,
    MAX(score) as max_score,
    MIN(score) as min_score
FROM 
    scores
GROUP BY subject;
+---------+-----------+-----------+
| subject | max_score | min_score |
+---------+-----------+-----------+
| Math    |        95 |        75 |
| Science |        90 |        88 |
+---------+-----------+-----------+
2 rows in set (0.001 sec)
```


### WITH PARTITION
```sql
SELECT 
    student_id,
    subject,
    score,
    RANK() OVER (PARTITION BY subject ORDER BY score DESC) AS the_rank,
    DENSE_RANK() OVER (PARTITION BY subject ORDER BY score DESC) AS the_dense_rank,
    ROW_NUMBER() OVER (PARTITION BY subject ORDER BY score DESC) AS the_row_number
FROM 
    scores;
```

output:

```
+------------+---------+-------+----------+----------------+----------------+
| student_id | subject | score | the_rank | the_dense_rank | the_row_number |
+------------+---------+-------+----------+----------------+----------------+
|          1 | Math    |    95 |        1 |              1 |              1 |
|          3 | Math    |    95 |        1 |              1 |              2 |
|          2 | Math    |    85 |        3 |              2 |              3 |
|          4 | Math    |    75 |        4 |              3 |              4 |
|          1 | Science |    90 |        1 |              1 |              1 |
|          3 | Science |    90 |        1 |              1 |              2 |
|          2 | Science |    88 |        3 |              2 |              3 |
+------------+---------+-------+----------+----------------+----------------+
7 rows in set (0.000 sec)```


## Summary

	RANK() provides a rank with gaps for ties.
	
	DENSE_RANK() provides a rank without gaps for ties.
	
	ROW_NUMBER() provides a unique sequential number for each row.
	

	These functions are powerful tools for analysis 
	and reporting, allowing you to easily segment 
	and rank your data based on various criteria.



# References

[1. What’s the difference? — RANK() vs.DENSE_RANK() vs.ROW_NUMBER()](https://medium.com/@LoriLu/whats-the-difference-rank-vs-dense-rank-vs-row-number-3aca5ecfb928)

[2. MySQL RANK Function](https://www.mysqltutorial.org/mysql-window-functions/mysql-rank-function)

[3. Rank functions in MySQL](https://medium.com/@emad-mohamed/rank-functions-in-mysql-e76762c210a6)