<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="Author" CONTENT="James Hoffman">
   <META NAME="Description" CONTENT="This is an introduction to Structured Query Language">
   <META NAME="KeyWords" CONTENT="SQL, Tutorial, Structured, Query, Language, Database, Programming">
   <META NAME="Content" CONTENT="Introduction to Structured Query Language">
   <TITLE>SQL Tutorial</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000FF" VLINK="#800080" ALINK="#0000FF">

<H1>
<FONT COLOR="#0000FF">Introduction to Structured Query Language</FONT></H1>
<B><TT><FONT COLOR="#FF0000"><FONT SIZE=+1>Version 4.34</FONT></FONT></TT></B>
<P>This page is a tutorial of the <I>Structured Query Language </I>(also
known as <B>SQL</B>) and is a pioneering effort on the World Wide Web,
as this is the first comprehensive SQL tutorial available on the Internet.
SQL allows users to access data in relational database management systems,
such as Oracle, Sybase, Informix, Microsoft SQL Server, Access, and others,
by allowing users to describe the data the user wishes to see. SQL also
allows users to define the data in a database, and manipulate that data.
This page will describe how to use SQL, and give examples. The SQL used
in this document is "ANSI", or standard SQL, and no SQL features of specific
database management systems will be discussed until the "Nonstandard SQL"
section. It is recommended that you print this page, so that you can easily
refer back to previous examples.
<P>Also, you may be interested in joining the new <A HREF="http://clubs.yahoo.com/clubs/structuredquerylanguage">SQL
Club on Yahoo!</A>, where you can read or enter messages in a SQL forum.
<P>
<HR WIDTH="100%"><B><FONT COLOR="#800040"><FONT SIZE=+2>Table of Contents</FONT></FONT></B>
<UL><A HREF="#Basics of the SELECT Statement">Basics of the SELECT Statement</A>
<BR><A HREF="#Conditional Selection">Conditional Selection</A>
<BR><A HREF="#Relational Operators">Relational Operators</A>
<BR><A HREF="#Compound Conditions">Compound Conditions</A>
<BR><A HREF="#IN & BETWEEN">IN &amp; BETWEEN</A>
<BR><A HREF="#Using LIKE">Using LIKE</A></UL>

<UL><A HREF="#Joins">Joins</A>
<BR><A HREF="#Keys">Keys</A>
<BR><A HREF="#Performing a Join">Performing a Join</A>
<BR><A HREF="#Eliminating Duplicates">Eliminating Duplicates</A>
<BR><A HREF="#Aliases & In/Subqueries">Aliases &amp; In/Subqueries</A>
<P><A HREF="#Aggregate Functions">Aggregate Functions</A>
<BR><A HREF="#Views">Views</A>
<BR><A HREF="#Creating New Tables">Creating New Tables</A>
<BR><A HREF="#Altering Tables">Altering Tables</A>
<BR><A HREF="#Adding Data">Adding Data</A>
<BR><A HREF="#Deleting Data">Deleting Data</A>
<BR><A HREF="#Updating Data">Updating Data</A></UL>

<UL><A HREF="#Indexes">Indexes</A>
<BR><A HREF="#GROUP BY & HAVING">GROUP BY &amp; HAVING</A>
<BR><A HREF="#More Subqueries">More Subqueries</A>
<BR><A HREF="#EXISTS & ALL">EXISTS &amp; ALL</A>
<BR><A HREF="#UNION & Outer Joins">UNION &amp; Outer Joins</A>
<BR><A HREF="#Embedded SQL">Embedded SQL</A>
<BR><A HREF="#Common SQL Questions">Common SQL Questions</A>
<BR><A HREF="#Nonstandard SQL">Nonstandard SQL</A>
<BR><A HREF="#Syntax Summary">Syntax Summary</A>
<BR><A HREF="#Important Links">Important Links</A></UL>

<HR><A NAME="Basics of the SELECT Statement"></A><B><FONT SIZE=+2>Basics
of the SELECT Statement</FONT></B>
<P>In a relational database, data is stored in tables. An example table
would relate Social Security Number, Name, and Address:
<BR>&nbsp;
<TABLE BORDER >
<TR>
<TH COLSPAN="6">
<CENTER><B>EmployeeAddressTable</B></CENTER>
</TH>
</TR>

<TR>
<TD NOWRAP><B>SSN</B></TD>

<TD NOWRAP><B>FirstName</B></TD>

<TD NOWRAP><B>LastName</B></TD>

<TD NOWRAP><B>Address</B></TD>

<TD NOWRAP><B>City</B></TD>

<TD NOWRAP><B>State</B></TD>
</TR>

<TR>
<TD NOWRAP>512687458</TD>

<TD NOWRAP>Joe</TD>

<TD NOWRAP>Smith&nbsp;</TD>

<TD NOWRAP>83 First Street</TD>

<TD NOWRAP>Howard</TD>

<TD NOWRAP>Ohio&nbsp;</TD>
</TR>

<TR>
<TD NOWRAP>758420012</TD>

<TD NOWRAP>Mary</TD>

<TD NOWRAP>Scott&nbsp;</TD>

<TD NOWRAP>842 Vine Ave.</TD>

<TD NOWRAP>Losantiville</TD>

<TD NOWRAP>Ohio&nbsp;</TD>
</TR>

<TR>
<TD NOWRAP>102254896</TD>

<TD NOWRAP>Sam</TD>

<TD NOWRAP>Jones&nbsp;</TD>

<TD NOWRAP>33 Elm St.</TD>

<TD NOWRAP>Paris</TD>

<TD NOWRAP>New York&nbsp;</TD>
</TR>

<TR>
<TD NOWRAP>876512563</TD>

<TD NOWRAP>Sarah</TD>

<TD NOWRAP>Ackerman&nbsp;</TD>

<TD NOWRAP>440 U.S. 110</TD>

<TD NOWRAP>Upton</TD>

<TD NOWRAP>Michigan&nbsp;</TD>
</TR>
</TABLE>

<P>Now, let's say you want to see the address of each employee. Use the
SELECT statement, like so:
<P><TT>SELECT FirstName, LastName, Address, City, State</TT>
<BR><TT>FROM EmployeeAddressTable;</TT>
<P>The following is the results of your <I>query</I> of the database:
<BR>&nbsp;
<TABLE BORDER >
<TR>
<TD NOWRAP><B>First Name</B></TD>

<TD NOWRAP><B>Last Name</B></TD>

<TD NOWRAP><B>Address</B></TD>

<TD NOWRAP><B>City</B></TD>

<TD NOWRAP><B>State</B></TD>
</TR>

<TR>
<TD NOWRAP>Joe</TD>

<TD NOWRAP>Smith</TD>

<TD NOWRAP>83 First Street&nbsp;</TD>

<TD NOWRAP>Howard</TD>

<TD NOWRAP>Ohio</TD>
</TR>

<TR>
<TD NOWRAP>Mary</TD>

<TD NOWRAP>Scott</TD>

<TD NOWRAP>842 Vine Ave.&nbsp;</TD>

<TD NOWRAP>Losantiville</TD>

<TD NOWRAP>Ohio</TD>
</TR>

<TR>
<TD NOWRAP>Sam</TD>

<TD NOWRAP>Jones</TD>

<TD NOWRAP>33 Elm St.&nbsp;</TD>

<TD NOWRAP>Paris</TD>

<TD NOWRAP>New York</TD>
</TR>

<TR>
<TD NOWRAP>Sarah</TD>

<TD NOWRAP>Ackerman</TD>

<TD NOWRAP>440 U.S. 110&nbsp;</TD>

<TD NOWRAP>Upton</TD>

<TD NOWRAP>Michigan</TD>
</TR>
</TABLE>

<P>To explain what you just did, you asked for the all of data in the EmployeeAddressTable,
and specifically, you asked for the <I>columns</I> called FirstName, LastName,
Address, City, and State. Note that column names and table names do not
have spaces...they must be typed as one word; and that the statement ends
with a semicolon (;). The general form for a SELECT statement, retrieving
all of the <I>rows</I> in the table is:
<P><TT>SELECT ColumnName, ColumnName, ...</TT>
<BR><TT>FROM TableName;</TT>
<P>To get all columns of a table without typing all column names, use:
<P><TT>SELECT * FROM TableName;</TT>
<P>Each database management system (DBMS) and database software has different
methods for logging in to the database and entering SQL commands; see the
local computer "guru" to help you get onto the system, so that you can
use SQL.&nbsp;
<HR><A NAME="Conditional Selection"></A><B><FONT SIZE=+2>Conditional Selection</FONT></B>
<P>To further discuss the SELECT statement, let's look at a new example
table (for hypothetical purposes only):
<BR>&nbsp;
<TABLE BORDER >
<TR>
<TD COLSPAN="4" WIDTH="541">
<CENTER><B>EmployeeStatisticsTable</B></CENTER>
</TD>
</TR>

<TR>
<TD WIDTH="139"><B>EmployeeIDNo</B></TD>

<TD WIDTH="134"><B>Salary</B></TD>

<TD WIDTH="134"><B>Benefits</B></TD>

<TD WIDTH="134"><B>Position</B></TD>
</TR>

<TR>
<TD WIDTH="139">010</TD>

<TD WIDTH="134">75000</TD>

<TD WIDTH="134">15000&nbsp;</TD>

<TD WIDTH="134">Manager</TD>
</TR>

<TR>
<TD WIDTH="139">105</TD>

<TD WIDTH="134">65000</TD>

<TD WIDTH="134">15000&nbsp;</TD>

<TD WIDTH="134">Manager</TD>
</TR>

<TR>
<TD WIDTH="139">152</TD>

<TD WIDTH="134">60000</TD>

<TD WIDTH="134">15000&nbsp;</TD>

<TD WIDTH="134">Manager</TD>
</TR>

<TR>
<TD WIDTH="139">215</TD>

<TD WIDTH="134">60000</TD>

<TD WIDTH="134">12500&nbsp;</TD>

<TD WIDTH="134">Manager</TD>
</TR>

<TR>
<TD WIDTH="139">244</TD>

<TD WIDTH="134">50000</TD>

<TD WIDTH="134">12000&nbsp;</TD>

<TD WIDTH="134">Staff</TD>
</TR>

<TR>
<TD WIDTH="139">300</TD>

<TD WIDTH="134">45000</TD>

<TD WIDTH="134">10000&nbsp;</TD>

<TD WIDTH="134">Staff</TD>
</TR>

<TR>
<TD WIDTH="139">335</TD>

<TD WIDTH="134">40000</TD>

<TD WIDTH="134">10000&nbsp;</TD>

<TD WIDTH="134">Staff</TD>
</TR>

<TR>
<TD WIDTH="139">400</TD>

<TD WIDTH="134">32000</TD>

<TD WIDTH="134">7500&nbsp;</TD>

<TD WIDTH="134">Entry-Level</TD>
</TR>

<TR>
<TD WIDTH="139">441</TD>

<TD WIDTH="134">28000</TD>

<TD WIDTH="134">7500&nbsp;</TD>

<TD WIDTH="134">Entry-Level</TD>
</TR>
</TABLE>

<H4>

<HR WIDTH="100%"><A NAME="Relational Operators"></A>Relational Operators</H4>
There are six Relational Operators in SQL, and after introducing them,
we'll see how they're used:
<BR>&nbsp;
<TABLE BORDER >
<TR>
<TD WIDTH="103">=</TD>

<TD WIDTH="180">Equal</TD>
</TR>

<TR>
<TD WIDTH="103">&lt;> or != (see manual)</TD>

<TD WIDTH="180">Not Equal&nbsp;</TD>
</TR>

<TR>
<TD WIDTH="103">&lt;</TD>

<TD WIDTH="180">Less Than</TD>
</TR>

<TR>
<TD WIDTH="103">></TD>

<TD WIDTH="180">Greater Than</TD>
</TR>

<TR>
<TD WIDTH="103">&lt;=</TD>

<TD WIDTH="180">Less Than or Equal To</TD>
</TR>

<TR>
<TD WIDTH="103">>=</TD>

<TD WIDTH="180">Greater Than or Equal To&nbsp;</TD>
</TR>
</TABLE>

<P>The <I>WHERE </I>clause is used to specify that only certain rows of
the table are displayed, based on the criteria described in that <I>WHERE
clause</I>. It is most easily understood by looking at a couple of examples.
<P>If you wanted to see the EMPLOYEEIDNO's of those making at or over $50,000,
use the following:
<P><TT>SELECT EMPLOYEEIDNO</TT>
<BR><TT>FROM EMPLOYEESTATISTICSTABLE</TT>
<BR><TT>WHERE SALARY >= 50000;</TT>
<P>Notice that the >= (greater than or equal to) sign is used, as we wanted
to see those who made greater than $50,000, or equal to $50,000, listed
together. This displays:
<P><TT>EMPLOYEEIDNO</TT>
<BR><TT>------------</TT>
<BR><TT>010</TT>
<BR><TT>105</TT>
<BR><TT>152</TT>
<BR><TT>215</TT>
<BR><TT>244</TT>
<P>The <I>WHERE</I> description, SALARY >= 50000, is known as a <I>condition</I>
(an operation which evaluates to True or False)<I>.</I> The same can be
done for text columns:
<P><TT>SELECT EMPLOYEEIDNO</TT>
<BR><TT>FROM EMPLOYEESTATISTICSTABLE</TT>
<BR><TT>WHERE POSITION = 'Manager';</TT>
<P>This displays the ID Numbers of all Managers. Generally, with text columns,
stick to equal to or not equal to, and make sure that any text that appears
in the statement is surrounded by single quotes ('). <B><I>Note:</I></B>
Position is now an illegal identifier because it is now an unused, but
reserved, keyword in the SQL-92 standard.
<P>
<HR WIDTH="100%"><A NAME="Compound Conditions"></A><FONT SIZE=+1>More Complex
Conditions: Compound Conditions / Logical Operators</FONT>
<P>The <I>AND</I> operator joins two or more conditions, and displays a
row only if that row's data satisfies <B>ALL</B> conditions listed (i.e.
all conditions hold true). For example, to display all staff making over
$40,000, use:
<P><TT>SELECT EMPLOYEEIDNO</TT>
<BR><TT>FROM EMPLOYEESTATISTICSTABLE</TT>
<BR><TT>WHERE SALARY > 40000 AND POSITION = 'Staff';</TT>
<P>The <I>OR</I> operator joins two or more conditions, but returns a row
if <B>ANY</B> of the conditions listed hold true. To see all those who
make less than $40,000 or have less than $10,000 in benefits, listed together,
use the following query:
<P><TT>SELECT EMPLOYEEIDNO</TT>
<BR><TT>FROM EMPLOYEESTATISTICSTABLE</TT>
<BR><TT>WHERE SALARY &lt; 40000 OR BENEFITS &lt; 10000;</TT>
<P>AND &amp; OR can be combined, for example:
<P><TT>SELECT EMPLOYEEIDNO</TT>
<BR><TT>FROM EMPLOYEESTATISTICSTABLE</TT>
<BR><TT>WHERE POSITION = 'Manager' AND SALARY > 60000 OR BENEFITS > 12000;</TT>
<P>First, SQL finds the rows where the salary is greater than $60,000 and
the position column is equal to Manager, then taking this new list of rows,
SQL then sees if any of these rows satisfies the previous AND condition
or the condition that the Benefits column is greater than $12,000. Subsequently,
SQL only displays this second new list of rows, keeping in mind that anyone
with Benefits over $12,000 will be included as the OR operator includes
a row if either resulting condition is True. Also note that the AND operation
is done first.
<P>To generalize this process, SQL performs the AND operation(s) to determine
the rows where the AND operation(s) hold true (remember: all of the conditions
are true), then these results are used to compare with the OR conditions,
and only display those remaining rows where any of the conditions joined
by the OR operator hold true (where a condition or result from an AND is
paired with another condition or AND result to use to evaluate the OR,
which evaluates to true if either value is true). Mathematically, SQL evaluates
all of the conditions, then evaluates the AND "pairs", and then evaluates
the OR's (where both operators evaluate left to right).
<P>To look at an example, for a given row for which the DBMS is evaluating
the SQL statement Where clause to determine whether to include the row
in the query result (the whole Where clause evaluates to True), the DBMS
has evaluated all of the conditions, and is ready to do the logical comparisons
on this result:
<P><TT>True AND False OR True AND True OR False AND False</TT>
<P>First simplify the AND pairs:
<P><TT>False OR True OR False</TT>
<P>Now do the OR's, left to right:
<P><TT>True OR False</TT>
<BR><TT>True</TT>
<P>The result is True, and the row passes the query conditions. Be sure
to see the next section on NOT's, and the order of logical operations.
I hope that this section has helped you understand AND's or OR's, as it's
a difficult subject to explain briefly (especially when you write a version
and the editor loses the changes--on multiple occasions no less!).
<P>To perform OR's before AND's, like if you wanted to see a list of employees
making a large salary (>$50,000) or have a large benefit package (>$10,000),
and that happen to be a manager, use parentheses:
<P><TT>SELECT EMPLOYEEIDNO</TT>
<BR><TT>FROM EMPLOYEESTATISTICSTABLE</TT>
<BR><TT>WHERE POSITION = 'Manager' AND (SALARY > 50000 OR BENEFITS > 10000);</TT>
<P>
<HR WIDTH="100%"><A NAME="IN & BETWEEN"></A><B><I>IN &amp; BETWEEN</I></B>
<P>An easier method of using compound conditions uses <I>IN</I> or <I>BETWEEN.</I>
For example, if you wanted to list all managers and staff:
<P><TT>SELECT EMPLOYEEIDNO</TT>
<BR><TT>FROM EMPLOYEESTATISTICSTABLE</TT>
<BR><TT>WHERE POSITION IN ('Manager', 'Staff');</TT>
<P>or to list those making greater than or equal to $30,000, but less than
or equal to $50,000, use:
<P><TT>SELECT EMPLOYEEIDNO</TT>
<BR><TT>FROM EMPLOYEESTATISTICSTABLE</TT>
<BR><TT>WHERE SALARY BETWEEN 30000 AND 50000;</TT>
<P>To list everyone not in this range, try:
<P><TT>SELECT EMPLOYEEIDNO</TT>
<BR><TT>FROM EMPLOYEESTATISTICSTABLE</TT>
<BR><TT>WHERE SALARY NOT BETWEEN 30000 AND 50000;</TT>
<P>Similarly, NOT IN lists all rows excluded from the <I>IN</I> list.
<P>Additionally, NOT's can be thrown in with AND's &amp; OR's, except that
NOT is a unary operator (evaluates one condition, reversing its value,
whereas, AND's &amp; OR's evaluate two conditions), and that all NOT's
are performed before any AND's or OR's.
<P><B><I>SQL Order of Logical Operations (each operates from left to right)</I></B>
<OL>
<LI>
<TT><FONT SIZE=+1>NOT</FONT></TT></LI>

<LI>
<TT><FONT SIZE=+1>AND</FONT></TT></LI>

<LI>
<TT><FONT SIZE=+1>OR</FONT></TT></LI>
</OL>

<HR WIDTH="100%"><A NAME="Using LIKE"></A><B>Using<I> LIKE</I></B>
<P>Look at the EmployeeStatisticsTable, and say you wanted to see all people
whose last names started with "S"; try:
<P><TT>SELECT EMPLOYEEIDNO</TT>
<BR><TT>FROM EMPLOYEEADDRESSTABLE</TT>
<BR><TT>WHERE LASTNAME LIKE 'S%';</TT>
<P>The percent sign (%) is used to represent any possible character (number,
letter, or punctuation) or set of characters that might appear after the
"S". To find those people with LastName's ending in "S", use '%S', or if
you wanted the "S" in the middle of the word, try '%S%'. The '%' can be
used for any characters in the same position relative to the given characters.
NOT LIKE displays rows not fitting the given description. Other possiblities
of using LIKE, or any of these discussed conditionals, are available, though
it depends on what DBMS you are using; as usual, consult a manual or your
system manager or administrator for the available features on your system,
or just to make sure that what you are trying to do is available and allowed.
This disclaimer holds for the features of SQL that will be discussed below.
This section is just to give you an idea of the possibilities of queries
that can be written in SQL.&nbsp;
<HR WIDTH="100%"><A NAME="Joins"></A><B><FONT SIZE=+2>Joins</FONT></B>
<P>In this section, we will only discuss <I>inner</I> joins, and <I>equijoins</I>,
as in general, they are the most useful. For more information, try the
SQL links at the bottom of the page.
<P>Good database design suggests that each table lists data only about
a single <I>entity</I>, and detailed information can be obtained in a relational
database, by using additional tables, and by using a <I>join</I>.
<P>First, take a look at these example tables:
<BR>&nbsp;
<TABLE BORDER >
<CAPTION><B>AntiqueOwners</B></CAPTION>

<TR>
<TD><B>OwnerID</B></TD>

<TD><B>OwnerLastName</B></TD>

<TD><B>OwnerFirstName</B></TD>
</TR>

<TR>
<TD>01</TD>

<TD>Jones</TD>

<TD>Bill</TD>
</TR>

<TR>
<TD>02</TD>

<TD>Smith</TD>

<TD>Bob</TD>
</TR>

<TR>
<TD>15</TD>

<TD>Lawson</TD>

<TD>Patricia</TD>
</TR>

<TR>
<TD>21</TD>

<TD>Akins</TD>

<TD>Jane</TD>
</TR>

<TR>
<TD>50</TD>

<TD>Fowler</TD>

<TD>Sam</TD>
</TR>
</TABLE>

<P>
<HR ALIGN=LEFT WIDTH="75%">
<BR>&nbsp;
<TABLE BORDER >
<CAPTION><B>Orders</B></CAPTION>

<TR>
<TD><B>OwnerID</B></TD>

<TD><B>ItemDesired</B></TD>
</TR>

<TR>
<TD>02</TD>

<TD>Table</TD>
</TR>

<TR>
<TD>02</TD>

<TD>Desk</TD>
</TR>

<TR>
<TD>21</TD>

<TD>Chair</TD>
</TR>

<TR>
<TD>15</TD>

<TD>Mirror</TD>
</TR>
</TABLE>

<P>
<HR ALIGN=LEFT WIDTH="50%">
<BR>&nbsp;
<TABLE BORDER >
<CAPTION><B>Antiques</B></CAPTION>

<TR>
<TD><B>SellerID</B></TD>

<TD><B>BuyerID</B></TD>

<TD><B>Item</B></TD>
</TR>

<TR>
<TD>01</TD>

<TD>50</TD>

<TD>Bed</TD>
</TR>

<TR>
<TD>02</TD>

<TD>15</TD>

<TD>Table</TD>
</TR>

<TR>
<TD>15</TD>

<TD>02</TD>

<TD>Chair</TD>
</TR>

<TR>
<TD>21</TD>

<TD>50</TD>

<TD>Mirror</TD>
</TR>

<TR>
<TD>50</TD>

<TD>01</TD>

<TD>Desk</TD>
</TR>

<TR>
<TD>01</TD>

<TD>21</TD>

<TD>Cabinet</TD>
</TR>

<TR>
<TD>02</TD>

<TD>21</TD>

<TD>Coffee Table</TD>
</TR>

<TR>
<TD>15</TD>

<TD>50</TD>

<TD>Chair</TD>
</TR>

<TR>
<TD>01</TD>

<TD>15</TD>

<TD>Jewelry Box</TD>
</TR>

<TR>
<TD>02</TD>

<TD>21</TD>

<TD>Pottery</TD>
</TR>

<TR>
<TD>21</TD>

<TD>02</TD>

<TD>Bookcase</TD>
</TR>

<TR>
<TD>50</TD>

<TD>01</TD>

<TD>Plant Stand</TD>
</TR>
</TABLE>

<P>
<HR WIDTH="100%"><A NAME="Keys"></A><B>Keys</B>
<P>First, let's discuss the concept of <I>keys</I>. A <I>primary key</I>
is a column or set of columns that uniquely identifies the rest of the
data in any given row. For example, in the AntiqueOwners table, the OwnerID
column uniquely identifies that row. This means two things: no two rows
can have the same OwnerID, and, even if two owners have the same first
and last names, the OwnerID column ensures that the two owners will not
be confused with each other, because the unique OwnerID column will be
used throughout the database to track the owners, rather than the names.
<P>A<I> foreign key</I> is a column in a table where that column is a primary
key of another table, which means that any data in a foreign key column
must have corresponding data in the other table where that column is the
primary key. In DBMS-speak, this correspondence is known as <I>referential
integrity</I>. For example, in the Antiques table, both the BuyerID and
SellerID are foreign keys to the primary key of the AntiqueOwners table
(OwnerID; for purposes of argument, one has to be an Antique Owner before
one can buy or sell any items), as, in both tables, the ID rows are used
to identify the owners or buyers and sellers, and that the OwnerID is the
primary key of the AntiqueOwners table. In other words, all of this "ID"
data is used to refer to the owners, buyers, or sellers of antiques, themselves,
without having to use the actual names.
<P>
<HR WIDTH="100%"><A NAME="Performing a Join"></A><B>Performing a Join</B>
<P>The purpose of these <I>keys</I> is so that data can be related across
tables, without having to repeat data in every table--this is the power
of relational databases. For example, you can find the names of those who
bought a chair without having to list the full name of the buyer in the
Antiques table...you can get the name by relating those who bought a chair
with the names in the AntiqueOwners table through the use of the OwnerID,
which <I>relates</I> the data in the two tables. To find the names of those
who bought a chair, use the following query:
<P><TT>SELECT OWNERLASTNAME, OWNERFIRSTNAME</TT>
<BR><TT>FROM ANTIQUEOWNERS, ANTIQUES</TT>
<BR><TT>WHERE BUYERID = OWNERID AND ITEM = 'Chair';</TT>
<P>Note the following about this query...notice that both tables involved
in the relation are listed in the FROM clause of the statement. In the
WHERE clause, first notice that the ITEM = 'Chair' part restricts the listing
to those who have bought (and in this example, thereby owns) a chair. Secondly,
notice how the ID columns are related from one table to the next by use
of the BUYERID = OWNERID clause. Only where ID's match across tables and
the item purchased is a chair (because of the AND), will the names from
the AntiqueOwners table be listed. Because the joining condition used an
equal sign, this join is called an <I>equijoin</I>. The result of this
query is two names: Smith, Bob &amp; Fowler, Sam.
<P><I>Dot notation</I> refers to prefixing the table names to column names,
to avoid ambiguity, as follows:
<P><TT>SELECT ANTIQUEOWNERS.OWNERLASTNAME, ANTIQUEOWNERS.OWNERFIRSTNAME</TT>
<BR><TT>FROM ANTIQUEOWNERS, ANTIQUES</TT>
<BR><TT>WHERE ANTIQUES.BUYERID = ANTIQUEOWNERS.OWNERID AND ANTIQUES.ITEM
= 'Chair';</TT>
<P>As the column names are different in each table, however, this wasn't
necessary.
<P>
<HR WIDTH="100%"><A NAME="Eliminating Duplicates"></A><B><I>DISTINCT</I>
and Eliminating Duplicates</B>
<P>Let's say that you want to list the ID and names of <B>only</B> those
people who have sold an antique. Obviously, you want a list where each
seller is only listed once--you don't want to know how many antiques a
person sold, just the fact that this person sold one (for counts, see the
Aggregate Function section below). This means that you will need to tell
SQL to eliminate duplicate sales rows, and just list each person only once.
To do this, use the <I>DISTINCT</I> keyword.
<P>First, we will need an equijoin to the AntiqueOwners table to get the
detail data of the person's LastName and FirstName. However, keep in mind
that since the SellerID column in the Antiques table is a foreign key to
the AntiqueOwners table, a seller will only be listed if there is a row
in the AntiqueOwners table listing the ID and names. We also want to eliminate
multiple occurences of the SellerID in our listing, so we use <I>DISTINCT
</I><B>on
the column where the repeats may occur.</B>
<P>To throw in one more twist, we will also want the list alphabetized
by LastName, then by FirstName (on a LastName tie). Thus, we will use the
<I>ORDER
BY</I> clause:
<P><TT>SELECT DISTINCT SELLERID, OWNERLASTNAME, OWNERFIRSTNAME</TT>
<BR><TT>FROM ANTIQUES, ANTIQUEOWNERS</TT>
<BR><TT>WHERE SELLERID = OWNERID</TT>
<BR><TT>ORDER BY OWNERLASTNAME, OWNERFIRSTNAME;</TT>
<P>In this example, since everyone has sold an item, we will get a listing
of all of the owners, in alphabetical order by last name. For future reference
(and in case anyone asks), this type of join is considered to be in the
category of <I>inner joins.</I>
<P>
<HR WIDTH="100%"><A NAME="Aliases & In/Subqueries"></A><B>Aliases &amp;
<I>In</I>/Subqueries</B>
<P>In this section, we will talk about <I>Aliases</I>, <I>In</I> and the
use of subqueries, and how these can be used in a 3-table example. First,
look at this query which prints the last name of those owners who have
placed an order and what the order is, only listing those orders which
can be filled (that is, there is a buyer who owns that ordered item):
<P><TT>SELECT OWN.OWNERLASTNAME Last Name, ORD.ITEMDESIRED Item Ordered</TT>
<BR><TT>FROM ORDERS ORD, ANTIQUEOWNERS OWN</TT>
<BR><TT>WHERE ORD.OWNERID = OWN.OWNERID</TT>
<BR><TT>AND ORD.ITEMDESIRED IN</TT>
<UL><TT>(SELECT ITEM</TT>
<BR><TT>FROM ANTIQUES);</TT></UL>
This gives:
<P><TT>Last Name Item Ordered</TT>
<BR><TT>--------- ------------</TT>
<BR><TT>Smith&nbsp;&nbsp;&nbsp;&nbsp; Table</TT>
<BR><TT>Smith&nbsp;&nbsp;&nbsp;&nbsp; Desk</TT>
<BR><TT>Akins&nbsp;&nbsp;&nbsp;&nbsp; Chair</TT>
<BR><TT>Lawson&nbsp;&nbsp;&nbsp; Mirror</TT>
<P>There are several things to note about this query:
<OL>
<LI>
First, the "Last Name" and "Item Ordered" in the Select lines gives the
headers on the report.</LI>

<LI>
The OWN &amp; ORD are aliases; these are new names for the two tables listed
in the FROM clause that are used as prefixes for all dot notations of column
names in the query (see above). This eliminates ambiguity, especially in
the equijoin WHERE clause where both tables have the column named OwnerID,
and the dot notation tells SQL that we are talking about two different
OwnerID's from the two different tables.</LI>

<LI>
Note that the Orders table is listed first in the FROM clause; this makes
sure listing is done off of that table, and the AntiqueOwners table is
only used for the detail information (Last Name).</LI>

<LI>
Most importantly, the AND in the WHERE clause forces the In Subquery to
be invoked ("= ANY" or "= SOME" are two equivalent uses of IN). What this
does is, the subquery is performed, returning all of the Items owned from
the Antiques table, as there is no WHERE clause. Then, for a row from the
Orders table to be listed, the ItemDesired must be in that returned list
of Items owned from the Antiques table, thus listing an item only if the
order can be filled from another owner. You can think of it this way: the
subquery returns a <I>set</I> of Items from which each ItemDesired in the
Orders table is compared; the In condition is true only if the ItemDesired
is in that returned set from the Antiques table.</LI>

<LI>
Also notice, that in this case, that there happened to be an antique available
for each one desired...obviously, that won't always be the case. In addition,
notice that when the IN, "= ANY", or "= SOME" is used, that these keywords
refer to any possible row matches, not column matches...that is, you cannot
put multiple columns in the subquery Select clause, in an attempt to match
the column in the outer Where clause to one of multiple possible column
values in the subquery; only one column can be listed in the subquery,
and the possible match comes from multiple
<I>row</I> values in that <I>one</I>
column, not vice-versa.</LI>
</OL>
Whew! That's enough on the topic of complex SELECT queries for now. Now
on to other SQL statements.&nbsp;
<HR WIDTH="100%"><B><FONT SIZE=+2>Miscellaneous SQL Statements</FONT></B>
<P><A NAME="Aggregate Functions"></A><B>Aggregate Functions</B>
<P>I will discuss five important <I>aggregate functions</I>: SUM, AVG,
MAX, MIN, and COUNT. They are called aggregate functions because they summarize
the results of a query, rather than listing all of the rows.
<UL>
<LI>
SUM () gives the total of all the rows, satisfying any conditions, of the
given column, where the given column is numeric.</LI>

<LI>
AVG () gives the average of the given column.</LI>

<LI>
MAX () gives the largest figure in the given column.</LI>

<LI>
MIN () gives the smallest figure in the given column.</LI>

<LI>
COUNT(*) gives the number of rows satisfying the conditions.</LI>
</UL>
Looking at the tables at the top of the document, let's look at three examples:
<P><TT>SELECT SUM(SALARY), AVG(SALARY)</TT>
<BR><TT>FROM EMPLOYEESTATISTICSTABLE;</TT>
<P>This query shows the total of all salaries in the table, and the average
salary of all of the entries in the table.
<P><TT>SELECT MIN(BENEFITS)</TT>
<BR><TT>FROM EMPLOYEESTATISTICSTABLE</TT>
<BR><TT>WHERE POSITION = 'Manager';</TT>
<P>This query gives the smallest figure of the Benefits column, of the
employees who are Managers, which is 12500.
<P><TT>SELECT COUNT(*)</TT>
<BR><TT>FROM EMPLOYEESTATISTICSTABLE</TT>
<BR><TT>WHERE POSITION = 'Staff';</TT>
<P>This query tells you how many employees have Staff status (3).
<P>
<HR WIDTH="100%"><A NAME="Views"></A><B>Views</B>
<P>In SQL, you might (check your DBA) have access to create views for yourself.
What a view does is to allow you to assign the results of a query to a
new, personal table, that you can use in other queries, where this new
table is given the view name in your FROM clause. When you access a view,
the query that is defined in your view creation statement is performed
(generally), and the results of that query look just like another table
in the query that you wrote invoking the view. For example, to create a
view:
<P><TT>CREATE VIEW ANTVIEW AS SELECT ITEMDESIRED FROM ORDERS;</TT>
<P>Now, write a query using this view as a table, where the table is just
a listing of all Items Desired from the Orders table:
<P><TT>SELECT SELLERID</TT>
<BR><TT>FROM ANTIQUES, ANTVIEW</TT>
<BR><TT>WHERE ITEMDESIRED = ITEM;</TT>
<P>This query shows all SellerID's from the Antiques table where the Item
in that table happens to appear in the Antview view, which is just all
of the Items Desired in the Orders table. The listing is generated by going
through the Antique Items one-by-one until there's a match with the Antview
view. Views can be used to restrict database access, as well as, in this
case, simplify a complex query.
<P>
<HR WIDTH="100%"><A NAME="Creating New Tables"></A><B>Creating New Tables</B>
<P>All tables within a database must be created at some point in time...let's
see how we would create the Orders table:
<P><TT>CREATE TABLE ORDERS</TT>
<BR><TT>(OWNERID INTEGER NOT NULL,</TT>
<BR><TT>ITEMDESIRED CHAR(40) NOT NULL);</TT>
<P>This statement gives the table name and tells the DBMS about each column
in the table. <B><I>Please note</I></B> that this statement uses generic
data types, and that the data types might be different, depending on what
DBMS you are using. As usual, check local listings. Some common generic
data types are:
<UL>
<LI>
Char(x) - A column of characters, where x is a number designating the maximum
number of characters allowed (maximum length) in the column.</LI>

<LI>
Integer - A column of whole numbers, positive or negative.</LI>

<LI>
Decimal(x, y) - A column of decimal numbers, where x is the maximum length
in digits of the decimal numbers in this column, and y is the maximum number
of digits allowed after the decimal point. The maximum (4,2) number would
be 99.99.</LI>

<LI>
Date - A date column in a DBMS-specific format.</LI>

<LI>
Logical - A column that can hold only two values: TRUE or FALSE.</LI>
</UL>
One other note, the NOT NULL means that the column must have a value in
each row. If NULL was used, that column may be left empty in a given row.
<P>
<HR WIDTH="100%"><A NAME="Altering Tables"></A><B>Altering Tables</B>
<P>Let's add a column to the Antiques table to allow the entry of the price
of a given Item:
<P><TT>ALTER TABLE ANTIQUES ADD (PRICE DECIMAL(8,2) NULL);</TT>
<P>The data for this new column can be updated or inserted as shown later.
<P>
<HR WIDTH="100%"><A NAME="Adding Data"></A><B>Adding Data</B>
<P>To insert rows into a table, do the following:
<P><TT>INSERT INTO ANTIQUES VALUES (21, 01, 'Ottoman', 200.00);</TT>
<P>This inserts the data into the table, as a new row, column-by-column,
in the pre-defined order. Instead, let's change the order and leave Price
blank:
<P><TT>INSERT INTO ANTIQUES (BUYERID, SELLERID, ITEM)</TT>
<BR><TT>VALUES (01, 21, 'Ottoman');</TT>
<P>
<HR WIDTH="100%"><A NAME="Deleting Data"></A><B>Deleting Data</B>
<P>Let's delete this new row back out of the database:
<P><TT>DELETE FROM ANTIQUES</TT>
<BR><TT>WHERE ITEM = 'Ottoman';</TT>
<P>But if there is another row that contains 'Ottoman', that row will be
deleted also. Let's delete all rows (one, in this case) that contain the
specific data we added before:
<P><TT>DELETE FROM ANTIQUES</TT>
<BR><TT>WHERE ITEM = 'Ottoman' AND BUYERID = 01 AND SELLERID = 21;</TT>
<P>
<HR WIDTH="100%"><A NAME="Updating Data"></A><B>Updating Data</B>
<P>Let's update a Price into a row that doesn't have a price listed yet:
<P><TT>UPDATE ANTIQUES SET PRICE = 500.00 WHERE ITEM = 'Chair';</TT>
<P>This sets all Chair's Prices to 500.00. As shown above, more WHERE conditionals,
using AND, must be used to limit the updating to more specific rows. Also,
additional columns may be set by separating equal statements with commas.
<P>
<HR WIDTH="100%"><B><FONT SIZE=+2>Miscellaneous Topics</FONT></B>
<P><A NAME="Indexes"></A><B><I><FONT SIZE=+1>Indexes</FONT></I></B>
<P>Indexes allow a DBMS to access data quicker (<I>please note:</I> this
feature is nonstandard/not available on all systems). The system creates
this internal data structure (the index) which causes selection of rows,
when the selection is based on indexed columns, to occur faster. This index
tells the DBMS where a certain row is in the table given an indexed-column
value, much like a book index tells you what page a given word appears.
Let's create an index for the OwnerID in the AntiqueOwners column:
<P><TT>CREATE INDEX OID_IDX ON ANTIQUEOWNERS (OWNERID);</TT>
<P>Now on the names:
<P><TT>CREATE INDEX NAME_IDX ON ANTIQUEOWNERS (OWNERLASTNAME, OWNERFIRSTNAME);</TT>
<P>To get rid of an index, drop it:
<P><TT>DROP INDEX OID_IDX;</TT>
<P>By the way, you can also "drop" a table, as well (careful!--that means
that your table is deleted). In the second example, the index is kept on
the two columns, aggregated together--strange behavior might occur in this
situation...check the manual before performing such an operation.
<P>Some DBMS's do not enforce primary keys; in other words, the uniqueness
of a column is not enforced automatically. What that means is, if, for
example, I tried to insert another row into the AntiqueOwners table with
an OwnerID of 02, some systems will allow me to do that, even though we
do not, as that column is supposed to be unique to that table (every row
value is supposed to be different). One way to get around that is to create
a unique index on the column that we want to be a primary key, to force
the system to enforce prohibition of duplicates:
<P><TT>CREATE UNIQUE INDEX OID_IDX ON ANTIQUEOWNERS (OWNERID);</TT>
<P>
<HR WIDTH="100%"><A NAME="GROUP BY & HAVING"></A><B><I><FONT SIZE=+1>GROUP
BY &amp; HAVING</FONT></I></B>
<P>One special use of GROUP BY is to associate an aggregate function (especially
COUNT; counting the number of rows in each group) with groups of rows.
First, assume that the Antiques table has the Price column, and each row
has a value for that column. We want to see the price of the most expensive
item bought by each owner. We have to tell SQL to <I>group</I> each owner's
purchases, and tell us the maximum purchase price:
<P><TT>SELECT BUYERID, MAX(PRICE)</TT>
<BR><TT>FROM ANTIQUES</TT>
<BR><TT>GROUP BY BUYERID;</TT>
<P>Now, say we only want to see the maximum purchase price if the purchase
is over $1000, so we use the HAVING clause:
<P><TT>SELECT BUYERID, MAX(PRICE)</TT>
<BR><TT>FROM ANTIQUES</TT>
<BR><TT>GROUP BY BUYERID</TT>
<BR><TT>HAVING PRICE > 1000;</TT>
<P>
<HR WIDTH="100%"><A NAME="More Subqueries"></A><B><I><FONT SIZE=+1>More
Subqueries</FONT></I></B>
<P>Another common usage of subqueries involves the use of operators to
allow a Where condition to include the Select output of a subquery. First,
list the buyers who purchased an expensive item (the Price of the item
is $100 greater than the average price of all items purchased):
<P><TT>SELECT BUYERID</TT>
<BR><TT>FROM ANTIQUES</TT>
<BR><TT>WHERE PRICE ></TT>
<UL><TT>(SELECT AVG(PRICE) + 100</TT>
<BR><TT>FROM ANTIQUES);</TT></UL>
The subquery calculates the average Price, plus $100, and using that figure,
an OwnerID is printed for every item costing over that figure. One could
use DISTINCT BUYERID, to eliminate duplicates.
<P>List the Last Names of those in the AntiqueOwners table, ONLY if they
have bought an item:
<P><TT>SELECT OWNERLASTNAME</TT>
<BR><TT>FROM ANTIQUEOWNERS</TT>
<BR><TT>WHERE OWNERID IN</TT>
<UL><TT>(SELECT DISTINCT BUYERID</TT>
<BR><TT>FROM ANTIQUES);</TT></UL>
The subquery returns a list of buyers, and the Last Name is printed for
an Antique Owner if and only if the Owner's ID appears in the subquery
list (sometimes called a <I>candidate list</I>). <I>Note:</I> on some DBMS's,
equals can be used instead of IN, but for clarity's sake, since a set is
returned from the subquery, IN is the better choice.
<P>For an Update example, we know that the gentleman who bought the bookcase
has the wrong First Name in the database...it should be John:
<P><TT>UPDATE ANTIQUEOWNERS</TT>
<BR><TT>SET OWNERFIRSTNAME = 'John'</TT>
<BR><TT>WHERE OWNERID =</TT>
<UL><TT>(SELECT BUYERID</TT>
<BR><TT>FROM ANTIQUES</TT>
<BR><TT>WHERE ITEM = 'Bookcase');</TT></UL>
First, the subquery finds the BuyerID for the person(s) who bought the
Bookcase, then the outer query updates his First Name.
<P><B>Remember this rule about subqueries:</B> when you have a subquery
as part of a WHERE condition, the Select clause in the subquery must have
columns that match in number and type to those in the Where clause of the
outer query. In other words, if you have "<TT>WHERE ColumnName = (SELECT...);</TT>",
the Select must have only one column in it, to match the ColumnName in
the outer Where clause, <I>and</I> they must match in type (both being
integers, both being character strings, etc.).
<P>
<HR WIDTH="100%"><A NAME="EXISTS & ALL"></A><B><I><FONT SIZE=+1>EXISTS
&amp; ALL</FONT></I></B>
<P>EXISTS uses a subquery as a condition, where the condition is True if
the subquery returns any rows, and False if the subquery does not return
any rows; this is a nonintuitive feature with few unique uses. However,
if a prospective customer wanted to see the list of Owners only if the
shop dealt in Chairs, try:
<P><TT>SELECT OWNERFIRSTNAME, OWNERLASTNAME</TT>
<BR><TT>FROM ANTIQUEOWNERS</TT>
<BR><TT>WHERE EXISTS</TT>
<UL><TT>(SELECT *</TT>
<BR><TT>FROM ANTIQUES</TT>
<BR><TT>WHERE ITEM = 'Chair');</TT></UL>
If there are any Chairs in the Antiques column, the subquery would return
a row or rows, making the EXISTS clause true, causing SQL to list the Antique
Owners. If there had been no Chairs, no rows would have been returned by
the outside query.
<P>ALL is another unusual feature, as ALL queries can usually be done with
different, and possibly simpler methods; let's take a look at an example
query:
<P><TT>SELECT BUYERID, ITEM</TT>
<BR><TT>FROM ANTIQUES</TT>
<BR><TT>WHERE PRICE >= ALL</TT>
<UL><TT>(SELECT PRICE</TT>
<BR><TT>FROM ANTIQUES);</TT></UL>
This will return the largest priced item (or more than one item if there
is a tie), and its buyer. The subquery returns a list of all Prices in
the Antiques table, and the outer query goes through each row of the Antiques
table, and if its Price is greater than or equal to every (or ALL) Prices
in the list, it is listed, giving the highest priced Item. The reason ">="
must be used is that the highest priced item will be equal to the highest
price on the list, because this Item is in the Price list.
<P>
<HR WIDTH="100%"><A NAME="UNION & Outer Joins"></A><B><I><FONT SIZE=+1>UNION
&amp; Outer Joins (briefly explained)</FONT></I></B>
<P>There are occasions where you might want to see the results of multiple
queries together, combining their output; use UNION. To merge the output
of the following two queries, displaying the ID's of all Buyers, plus all
those who have an Order placed:
<P><TT>SELECT BUYERID</TT>
<BR><TT>FROM ANTIQUES</TT>
<BR><TT>UNION</TT>
<BR><TT>SELECT OWNERID</TT>
<BR><TT>FROM ORDERS;</TT>
<P>Notice that SQL requires that the Select list (of columns) must match,
column-by-column, in data type. In this case BuyerID and OwnerID are of
the same data type (integer). Also notice that SQL does automatic duplicate
elimination when using UNION (as if they were two "sets"); in single queries,
you have to use DISTINCT.
<P>The <I>outer join</I> is used when a join query is "united" with the
rows not included in the join, and are especially useful if constant text
"flags" are included. First, look at the query:
<P><TT>SELECT OWNERID, 'is in both Orders &amp; Antiques'</TT>
<BR><TT>FROM ORDERS, ANTIQUES</TT>
<BR><TT>WHERE OWNERID = BUYERID</TT>
<BR><TT>UNION</TT>
<BR><TT>SELECT BUYERID, 'is in Antiques only'</TT>
<BR><TT>FROM ANTIQUES</TT>
<BR><TT>WHERE BUYERID NOT IN</TT>
<UL><TT>(SELECT OWNERID</TT>
<BR><TT>FROM ORDERS);</TT></UL>
The first query does a join to list any owners who are in both tables,
and putting a tag line after the ID repeating the quote. The UNION merges
this list with the next list. The second list is generated by first listing
those ID's not in the Orders table, thus generating a list of ID's excluded
from the join query. Then, each row in the Antiques table is scanned, and
if the BuyerID is not in this exclusion list, it is listed with its quoted
tag. There might be an easier way to make this list, but it's difficult
to generate the informational quoted strings of text.
<P>This concept is useful in situations where a primary key is related
to a foreign key, but the foreign key value for some primary keys is NULL.
For example, in one table, the primary key is a salesperson, and in another
table is customers, with their salesperson listed in the same row. However,
if a salesperson has no customers, that person's name won't appear in the
customer table. The outer join is used if the listing of <B>all</B> salespersons
is to be printed, listed with their customers, whether the salesperson
has a customer or not--that is, no customer is printed (a logical NULL
value) if the salesperson has no customers, but is in the salespersons
table. Otherwise, the salesperson will be listed with each customer.
<P>Another important related point about Nulls having to do with joins:
the order of tables listed in the From clause is very important. The rule
states that SQL "adds" the second table to the first; the first table listed
has any rows where there is a null on the join column displayed; if the
second table has a row with a null on the join column, that row from the
table listed second does not get joined, and thus included with the first
table's row data. This is another occasion (should you wish that data included
in the result) where an outer join is commonly used. The concept of nulls
is important, and it may be worth your time to investigate them further.
<P>ENOUGH QUERIES!!! you say?...now on to something completely different...
<P>
<HR WIDTH="100%"><A NAME="Embedded SQL"></A><B><I><FONT SIZE=+1>Embedded
SQL--an ugly example (do not write a program like this...for purposes of
argument ONLY)</FONT></I></B>
<P><TT>/* -To get right to it, here is an example program that uses Embedded</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; SQL. Embedded SQL allows programmers to connect
to a database and</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; include SQL code right in the program, so that
their programs can</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; use, manipulate, and process data from a database.</TT>
<BR><TT>&nbsp;&nbsp; -This example C Program (using Embedded SQL) will
print a report.</TT>
<BR><TT>&nbsp;&nbsp; -This program will have to be precompiled for the
SQL statements,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; before regular compilation.</TT>
<BR><TT>&nbsp;&nbsp; -The EXEC SQL parts are the same (standard), but the
surrounding C</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; code will need to be changed, including the
host variable</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; declarations, if you are using a different language.</TT>
<BR><TT>&nbsp;&nbsp; -Embedded SQL changes from system to system, so, once
again, check</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; local documentation, especially variable declarations
and logging</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; in procedures, in which network, DBMS, and operating
system</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; considerations are crucial. */</TT>
<P><TT>/************************************************/</TT>
<BR><TT>/* THIS PROGRAM IS NOT COMPILABLE OR EXECUTABLE */</TT>
<BR><TT>/* IT IS FOR EXAMPLE PURPOSES ONLY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*/</TT>
<BR><TT>/************************************************/</TT>
<P><TT>#include &lt;stdio.h></TT>
<P><TT>/* This section declares the host variables; these will be the</TT>
<BR><TT>&nbsp;&nbsp; variables your program uses, but also the variable
SQL will put</TT>
<BR><TT>&nbsp;&nbsp; values in or take values out. */</TT>
<BR><TT>EXEC SQL BEGIN DECLARE SECTION;</TT>
<BR><TT>&nbsp; int BuyerID;</TT>
<BR><TT>&nbsp; char FirstName[100], LastName[100], Item[100];</TT>
<BR><TT>EXEC SQL END DECLARE SECTION;</TT>
<P><TT>/* This includes the SQLCA variable, so that some error checking
can be done. */</TT>
<BR><TT>EXEC SQL INCLUDE SQLCA;</TT>
<P><TT>main() {</TT>
<P><TT>/* This is a possible way to log into the database */</TT>
<BR><TT>EXEC SQL CONNECT UserID/Password;</TT>
<P><TT>/* This code either says that you are connected or checks if an
error</TT>
<BR><TT>&nbsp;&nbsp; code was generated, meaning log in was incorrect or
not possible. */</TT>
<BR><TT>&nbsp; if(sqlca.sqlcode) {</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; printf(Printer, "Error connecting to database
server.\n");</TT>
<BR><TT>&nbsp;&nbsp;&nbsp; exit();</TT>
<BR><TT>&nbsp; }</TT>
<BR><TT>&nbsp; printf("Connected to database server.\n");</TT>
<P><TT>/* This declares a "Cursor". This is used when a query returns more</TT>
<BR><TT>&nbsp;&nbsp; than one row, and an operation is to be performed
on each row</TT>
<BR><TT>&nbsp;&nbsp; resulting from the query. With each row established
by this query,</TT>
<BR><TT>&nbsp;&nbsp; I'm going to use it in the report. Later, "Fetch"
will be used to</TT>
<BR><TT>&nbsp;&nbsp; pick off each row, one at a time, but for the query
to actually</TT>
<BR><TT>&nbsp;&nbsp; be executed, the "Open" statement is used. The "Declare"
just</TT>
<BR><TT>&nbsp;&nbsp; establishes the query. */</TT>
<BR><TT>EXEC SQL DECLARE ItemCursor CURSOR FOR</TT>
<BR><TT>&nbsp; SELECT ITEM, BUYERID</TT>
<BR><TT>&nbsp; FROM ANTIQUES</TT>
<BR><TT>&nbsp; ORDER BY ITEM;</TT>
<BR><TT>EXEC SQL OPEN ItemCursor;</TT>
<P><TT>/* +-- You may wish to put a similar error checking block here --+
*/</TT>
<P><TT>/* Fetch puts the values of the "next" row of the query in the host</TT>
<BR><TT>&nbsp;&nbsp; variables, respectively. However, a "priming fetch"
(programming</TT>
<BR><TT>&nbsp;&nbsp; technique) must first be done. When the cursor is
out of data, a</TT>
<BR><TT>&nbsp;&nbsp; sqlcode will be generated allowing us to leave the
loop. Notice</TT>
<BR><TT>&nbsp;&nbsp; that, for simplicity's sake, the loop will leave on
any sqlcode,</TT>
<BR><TT>&nbsp;&nbsp; even if it is an error code. Otherwise, specific code
checking must</TT>
<BR><TT>&nbsp;&nbsp; be performed. */</TT>
<BR><TT>EXEC SQL FETCH ItemCursor INTO :Item, :BuyerID;</TT>
<BR><TT>&nbsp; while(!sqlca.sqlcode) {</TT>
<P><TT>/* With each row, we will also do a couple of things. First, bump
the</TT>
<BR><TT>&nbsp;&nbsp; price up by $5 (dealer's fee) and get the buyer's
name to put in</TT>
<BR><TT>&nbsp;&nbsp; the report. To do this, I'll use an Update and a Select,
before</TT>
<BR><TT>&nbsp;&nbsp; printing the line on the screen. The update assumes
however, that</TT>
<BR><TT>&nbsp;&nbsp; a given buyer has only bought one of any given item,
or else the</TT>
<BR><TT>&nbsp;&nbsp; price will be increased too many times. Otherwise,
a "RowID" logic</TT>
<BR><TT>&nbsp;&nbsp; would have to be used (see documentation). Also notice
the colon</TT>
<BR><TT>&nbsp;&nbsp; before host variable names when used inside of SQL
statements. */</TT>
<P><TT>EXEC SQL UPDATE ANTIQUES</TT>
<BR><TT>&nbsp; SET PRICE = PRICE + 5</TT>
<BR><TT>&nbsp; WHERE ITEM = :Item AND BUYERID = :BuyerID;</TT>
<P><TT>EXEC SQL SELECT OWNERFIRSTNAME, OWNERLASTNAME</TT>
<BR><TT>&nbsp; INTO :FirstName, :LastName</TT>
<BR><TT>&nbsp; FROM ANTIQUEOWNERS</TT>
<BR><TT>&nbsp; WHERE BUYERID = :BuyerID;</TT>
<P><TT>&nbsp;&nbsp;&nbsp; printf("%25s %25s %25s", FirstName, LastName,
Item);</TT>
<P><TT>/* Ugly report--for example purposes only! Get the next row. */</TT>
<BR><TT>EXEC SQL FETCH ItemCursor INTO :Item, :BuyerID;</TT>
<BR><TT>&nbsp; }</TT>
<P><TT>/* Close the cursor, commit the changes (see below), and exit the</TT>
<BR><TT>&nbsp;&nbsp; program. */</TT>
<BR><TT>EXEC SQL CLOSE ItemCursor;</TT>
<BR><TT>EXEC SQL COMMIT RELEASE;</TT>
<BR><TT>&nbsp; exit();</TT>
<BR><TT>}</TT>
<P>
<HR WIDTH="100%"><A NAME="Common SQL Questions"></A><B><I><FONT SIZE=+1>Common
SQL Questions &amp; Advanced Topics</FONT></I></B>
<OL>
<LI>
Why can't I just ask for the first three rows in a table? --Because in
relational databases, rows are inserted in no particular order, that is,
the system inserts them in an arbitrary order; so, you can only request
rows using valid SQL features, like ORDER BY, etc.</LI>

<LI>
What is this DDL and DML I hear about? --DDL (Data Definition Language)
refers to (in SQL) the Create Table statement...DML (Data Manipulation
Language) refers to the Select, Update, Insert, and Delete statements.&nbsp;
Also, QML, referring to Select statements, stands for Query Manipulation
Language.</LI>

<LI>
Aren't database tables just files? --Well, DBMS's store data in files declared
by system managers before new tables are created (on large systems), but
the system stores the data in a special format, and may spread data from
one table over several files. In the database world, a set of files created
for a database is called a <I>tablespace</I>. In general, on small systems,
everything about a database (definitions and all table data) is kept in
one file.</LI>

<LI>
(Related question) Aren't database tables just like spreadsheets? --No,
for two reasons. First, spreadsheets can have data in a cell, but a cell
is more than just a row-column-intersection. Depending on your spreadsheet
software, a cell might also contain formulas and formatting, which database
tables cannot have (currently). Secondly, spreadsheet cells are often dependent
on the data in other cells. In databases, "cells" are independent, except
that columns are logically related (hopefully; together a row of columns
describe an entity), and, other than primary key and foreign key constraints,
each row in a table is independent from one another.</LI>

<LI>
How do I import a text file of data into a database? --Well, you can't
do it directly...you must use a utility, such as Oracle's SQL*Loader, or
write a program to load the data into the database. A program to do this
would simply go through each record of a text file, break it up into columns,
and do an Insert into the database.</LI>

<LI>
What web sites and computer books would you recommend for more information
about SQL and databases? --First, look at the sites at the bottom of this
page. I would especially suggest the following: <A HREF="http://www.inquiry.com/techtips/thesqlpro/">Ask
the SQL Pro</A> (self-explanatory), <A HREF="http://www.compapp.dcu.ie/databases/f017.html">DB
Ingredients</A> (more theorical topics), <A HREF="http://www-ccs.cs.umass.edu/db.html">DBMS
Lab/Links</A> (comprehensive academic DBMS link listing), <A HREF="http://www.princeton.edu/~hannahk/WebPubl.htm">Access
on the Web</A> (about web access of Access databases), <A HREF="http://www.muppetlabs.com/library/tech/tutorials.html">Tutorial
Page</A> (listing of other tutorials), and <A HREF="http://www.let.rug.nl/~s0367672/pm_int_e.htm">miniSQL</A>
(more information about the best known free DBMS). An <A HREF="http://www.edm2.com/0612/msql7.html">excellent
page</A> about relational database design was recently brought to my attention
by the author, <A HREF="mailto:lozano@blnet.com">Fernando Lozano</A> (you
may also wish to see his <A HREF="http://www.blnet.com/msqlpc">mSQL page</A>).
Also, if you wish to practice SQL on an interactive site (using Java technologies),
I highly recommend Frank Torres' (<A HREF="mailto:torresf@uswest.net">torresf@uswest.net</A>)
<A HREF="http://sqlcourse.com">site
at http://sqlcourse.com</A>.&nbsp; Frank did an outstanding job with his
site, and if you have a recent release browser, it's definitely worth a
visit.&nbsp; In addition, point your browser to <A HREF="http://www.tipworld.com">www.tipworld.com</A>,
and subscribe to their SQL e-mail Tips of the Day...they are oustanding;
Tim Quinlan goes into topics that I can't even begin to go into here, such
index data structures (B-trees and B+-trees) and join algorithms, so advanced
IT RDBMS pros will get a daily insight into these data management tools.</LI>
<P>Unfortunately, there is not a great deal of information on the web
about SQL; the list I have below is fairly comprehensive (definitely representative).
As far as books are concerned (go to <A HREF="http://www.amazon.com">amazon.com</A>
or <A HREF="http://www.bn.com">Barnes &amp; Noble</A> for more information),
I would suggest (for beginners to intermediate-level) "Oracle: The Complete
Reference" from Oracle and "Understanding SQL" from Sybex for general SQL
information. Also, I would recommend O'Reilly Publishing's books, and Joe
Celko's writings for advanced users. Additionally, I would suggest <A HREF="http://pbs.mcp.com/index.cfm">mcp.com</A>
for samples of computer books, and for specific DBMS info (especially in
the Access area), I recommend Que's "Using" series, and the books of Alison
Balter (search for these names at the bookstore sites for a list of titles).&nbsp;
Also, look for the recent publications, "SQL from the Ground Up" and "SQL
Unleashed".
<LI>
What is a <I>schema</I>? --A schema is a logical set of tables, such as
the Antiques database above...usually, it is thought of as simply "the
database", but a database can hold more than one schema. For example, a
<I>star
schema</I> is a set of tables where one large, central table holds all
of the important information, and is linked, via foreign keys, to <I>dimension</I>
tables which hold detail information, and can be used in a join to create
detailed reports.</LI>

<LI>
Show me an example of an <I>outer join.</I> --Well, from the questions
I receive, this is an extremely common example, and I'll show you both
the Oracle and Access queries...</LI>
<P>Think of the following Employee table (the employees are given numbers,
for simplicity):
<TABLE BORDER >
<TR>
<TD>Name</TD>

<TD>Department</TD>
</TR>

<TR>
<TD>1</TD>

<TD>10</TD>
</TR>

<TR>
<TD>2</TD>

<TD>10</TD>
</TR>

<TR>
<TD>3</TD>

<TD>20</TD>
</TR>

<TR>
<TD>4</TD>

<TD>30</TD>
</TR>

<TR>
<TD>5</TD>

<TD>30</TD>
</TR>
</TABLE>

<P>Now think of a department table:
<BR>&nbsp;
<TABLE BORDER >
<TR>
<TD>Department</TD>
</TR>

<TR>
<TD>10</TD>
</TR>

<TR>
<TD>20</TD>
</TR>

<TR>
<TD>30</TD>
</TR>

<TR>
<TD>40</TD>
</TR>
</TABLE>

<P>Now suppose you want to join the tables, seeing all of the employees
and all of the departments together...you'll have to use an outer join
which includes a null employee to go with Dept. 40.
<P>In the book, "Oracle 7: the Complete Reference", about outer joins,
"think of the (+), which must immediately follow the join column of the
table, as saying add an extra (null) row anytime there's no match". So,
in Oracle, try this query (the + goes on Employee, which adds the null
row on no match):
<P><TT>Select E.Name, D.Department</TT>
<BR><TT>From Department D, Employee E</TT>
<BR><TT>Where E.Department(+) = D.Department;</TT>
<P>This is a left (outer) join, in Access:
<P><TT>SELECT DISTINCTROW Employee.Name, Department.Department</TT>
<BR><TT>FROM Department LEFT JOIN Employee ON Department.Department = Employee.Department;</TT>
<P>And you get this result:
<BR>&nbsp;
<TABLE BORDER >
<TR>
<TD>Name</TD>

<TD>Department</TD>
</TR>

<TR>
<TD>1</TD>

<TD>10</TD>
</TR>

<TR>
<TD>2</TD>

<TD>10</TD>
</TR>

<TR>
<TD>3</TD>

<TD>20</TD>
</TR>

<TR>
<TD>4</TD>

<TD>30</TD>
</TR>

<TR>
<TD>5</TD>

<TD>30</TD>
</TR>

<TR>
<TD></TD>

<TD>40</TD>
</TR>
</TABLE>

<LI>
What are some general tips you would give to make my SQL queries and databases
better and faster (<I>optimized</I>)?</LI>

<UL>
<LI>
You should try, if you can, to avoid expressions in Selects, such as SELECT
ColumnA + ColumnB, etc. The <I>query optimizer</I> of the database, the
portion of the DBMS that determines the best way to get the required data
out of the database itself, handles expressions in such a way that would
normally require more time to retrieve the data than if columns were normally
selected, and the expression itself handled programmatically.</LI>

<LI>
Minimize the number of columns included in a Group By clause.</LI>

<LI>
If you are using a join, try to have the columns joined on (from both tables)
indexed.</LI>

<LI>
When in doubt, index.</LI>

<LI>
Unless doing multiple counts or a complex query, use COUNT(*) (the number
of rows generated by the query) rather than COUNT(Column_Name).</LI>
</UL>

<LI>
What is <I>normalization</I>? --Normalization is a technique of database
design that suggests that certain criteria be used when constructing a
table layout (deciding what columns each table will have, and creating
the key structure), where the idea is to eliminate redundancy of non-key
data across tables. Normalization is usually referred to in terms of <I>forms</I>,
and I will introduce only the first three, even though it is somewhat common
to use other, more advanced forms (fourth, fifth, Boyce-Codd; see documentation).</LI>
<P><I>First Normal Form</I> refers to moving data into separate tables
where the data in each table is of a similar type, and by giving each table
a primary key.
<P>Putting data in <I>Second Normal Form</I> involves removing to other
tables data that is only dependent of a part of the key. For example, if
I had left the names of the Antique Owners in the items table, that would
not be in Second Normal Form because that data would be redundant; the
name would be repeated for each item owned; as such, the names were placed
in their own table. The names themselves don't have anything to do with
the items, only the identities of the buyers and sellers.
<P><I>Third Normal Form</I> involves getting rid of anything in the tables
that doesn't depend solely on the primary key. Only include information
that is dependent on the key, and move off data to other tables that are
independent of the primary key, and create a primary key for the new tables.
<P>There is some redundancy to each form, and if data is in <I>3NF </I>(shorthand
for 3rd normal form), it is already in <I>1NF </I>and <I>2NF</I>. In terms
of data design then, arrange data so that any non-primary key columns are
dependent only on the <I>whole primary key</I>. If you take a look at the
sample database, you will see that the way then to navigate through the
database is through joins using common key columns.
<P>Two other important points in database design are using good, consistent,
logical, full-word names for the tables and columns, and the use of full
words in the database itself. On the last point, my database is lacking,
as I use numeric codes for identification. It is usually best, if possible,
to come up with keys that are, by themselves, self-explanatory; for example,
a better key would be the first four letters of the last name and first
initial of the owner, like JONEB for Bill Jones (or for tiebreaking purposes,
add numbers to the end to differentiate two or more people with similar
names, so you could try JONEB1, JONEB2, etc.).
<LI>
What is the difference between a <I>single-row query</I> and a <I>multiple-row
query</I> and why is it important to know the difference? --First, to cover
the obvious, a single-row query is a query that returns one row as its
result, and a multiple-row query is a query that returns more than one
row as its result. Whether a query returns one row or more than one row
is entirely dependent on the design (or <I>schema</I>) of the tables of
the database. As query-writer, you must be aware of the schema, be sure
to include enough conditions, and structure your SQL statement properly,
so that you will get the desired result (either one row or multiple rows).
For example, if you wanted to be sure that a query of the AntiqueOwners
table returned only one row, consider an equal condition of the primary
key-column, OwnerID.</LI>
<P>Three reasons immediately come to mind as to why this is important.
First, getting multiple rows when you were expecting only one, or vice-versa,
may mean that the query is erroneous, that the database is incomplete,
or simply, you learned something new about your data. Second, if you are
using an update or delete statement, you had better be sure that the statement
that you write performs the operation on the desired row (or rows)...or
else, you might be deleting or updating more rows than you intend. Third,
any queries written in Embedded SQL must be carefully thought out as to
the number of rows returned. If you write a single-row query, only one
SQL statement may need to be performed to complete the programming logic
required. If your query, on the other hand, returns multiple rows, you
will have to use the Fetch statement, and quite probably, some sort of
looping structure in your program will be required to iterate processing
on each returned row of the query.
<LI>
Tell me about a simple approach to relational database design. --This was
sent to me via a news posting; it was submitted by John Frame ( <A HREF="mailto:jframe@jframe.com">jframe@jframe.com</A>
) and Richard Freedman ( <A HREF="mailto:rfreedm@voicenet.com">rfreedm@voicenet.com</A>
); I offer a shortened version as advice, but I'm not responsible for it,
and some of the concepts are readdressed in the next question...</LI>
<P>First, create a list of important things (entities) and include
those things you may not initially believe is important. Second, draw a
line between any two entities that have any connection whatsoever; except
that no two entities can connect without a 'rule'; e.g.: families have
children, employees work for a department. Therefore put the 'connection'
in a diamond, the 'entities' in squares. Third, your picture should now
have many squares (entities) connected to other entities through diamonds
(a square enclosing an entity, with a line to a diamond describing the
relationship, and then another line to the other entity). Fourth, put descriptors
on each square and each diamond, such as customer -- airline -- trip. Fifth,
give each diamond and square any attributes it may have (a person has a
name, an invoice has a number), but some relationships have none (a parent
just owns a child). Sixth, everything on your page that has attributes
is now a table, whenever two entities have a relationship where the relationship
has no attributes, there is merely a foreign key between the tables. Seventh,
in general you want to make tables not repeat data. So, if a customer has
a name and several addresses, you can see that for every address of a customer,
there will be repeated the customer's first name, last name, etc. So, record
Name in one table, and put all his addresses in another. Eighth, each row
(record) should be unique from every other one; Mr. Freedman suggests a
'auto-increment number' primary key, where a new, unique number is generated
for each new inserted row. Ninth, a key is any way to uniquely identify
a row in a table...first and last name together are good as a 'composite'
key. That's the technique.
<LI>
What are <I>relationships?</I> --Another design question...the term "relationships"
(often termed "relation") usually refers to the relationships among primary
and foreign keys between tables. This concept is important because when
the tables of a relational database are designed, these relationships must
be defined because they determine which columns are or are not primary
or foreign keys. You may have heard of an
<B>Entity-Relationship Diagram</B>,
which is a graphical view of tables in a database schema, with lines connecting
related columns across tables. See the sample diagram at the end of this
section or some of the sites below in regard to this topic, as there are
many different ways of drawing E-R diagrams. But first, let's look at each
kind of relationship...</LI>
<P>A <I>One-to-one relationship</I> means that you have a primary key
column that is related to a foreign key column, and that for every primary
key value, there is <B>one</B> foreign key value. For example, in the first
example, the EmployeeAddressTable, we add an EmployeeIDNo column. Then,
the EmployeeAddressTable is related to the EmployeeStatisticsTable (second
example table) by means of that EmployeeIDNo. Specifically, each employee
in the EmployeeAddressTable <B>has</B> statistics (one row of data) in
the EmployeeStatisticsTable. Even though this is a contrived example, this
is a "1-1" relationship. Also notice the "has" in bold...when expressing
a relationship, it is important to describe the relationship with a verb.
<P>The other two kinds of relationships may or may not use logical primary
key and foreign key constraints...it is strictly a call of the designer.
The first of these is the <I>one-to-many relationship</I> ("1-M"). This
means that for every column value in one table, there is <B>one or more</B>
related values in another table. Key constraints may be added to the design,
or possibly just the use of some sort of identifier column may be used
to establish the relationship. An example would be that for every OwnerID
in the AntiqueOwners table, there are one or more (zero is permissible
too) Items <B>bought</B> in the Antiques table (verb: buy).
<P>Finally, the <I>many-to-many relationship</I> ("M-M") does not involve
keys generally, and usually involves idenifying columns. The unusual occurence
of a "M-M" means that one column in one table is related to another column
in another table, and for every value of one of these two columns, there
are one or more related values in the corresponding column in the other
table (and vice-versa), or more a common possibility, two tables have a
1-M relationship to each other (two relationships, one 1-M going each way).
A [bad] example of the more common situation would be if you had a job
assignment database, where one table held one row for each employee and
a job assignment, and another table held one row for each job with one
of the assigned employees. Here, you would have multiple rows for each
employee in the first table, one for each job assignment, and multiple
rows for each job in the second table, one for each employee assigned to
the project. These tables have a M-M: each employee in the first table
<B>has</B>
many job assignments from the second table, and each job <B>has</B> many
employees assigned to it from the first table. This is the tip of the iceberg
on this topic...see the links below for more information and see the diagram
below for a <I>simplified</I> example of an E-R diagram.
<BR><A HREF="http://w3.one.net/~jhoffman/erdiagrm.gif"><IMG SRC="erdiagrm.gif" ALT="Sample Simplified Entity-Relationship Diagram" HEIGHT=280 WIDTH=561></A>
<LI>
What are some important nonstandard SQL features (extremely common question)?
--Well, see the next section...</LI>
</OL>

<HR WIDTH="100%"><A NAME="Nonstandard SQL"></A><B><I><FONT SIZE=+1>Nonstandard
SQL..."check local listings"</FONT></I></B>
<UL>
<LI>
INTERSECT and MINUS are like the UNION statement, except that INTERSECT
produces rows that appear in both queries, and MINUS produces rows that
result from the first query, but not the second.</LI>

<LI>
Report Generation Features: the COMPUTE clause is placed at the end of
a query to place the result of an aggregate function at the end of a listing,
like <TT>COMPUTE SUM (PRICE); </TT>Another option is to use break logic:
define a break to divide the query results into groups based on a column,
like <TT>BREAK ON BUYERID</TT>. Then, to produce a result after the listing
of a group, use <TT>COMPUTE SUM OF PRICE ON BUYERID</TT>. If, for example,
you used all three of these clauses (BREAK first, COMPUTE on break second,
COMPUTE overall sum third), you would get a report that grouped items by
their BuyerID, listing the sum of Prices after each group of a BuyerID's
items, then, after all groups are listed, the sum of all Prices is listed,
all with SQL-generated headers and lines.</LI>

<LI>
In addition to the above listed aggregate functions, some DBMS's allow
more functions to be used in Select lists, except that these functions
(some character functions allow multiple-row results) are to be used with
an individual value (not groups), on <I>single-row queries. </I>The functions
are to be used only on appropriate data types, also. Here are some <B>Mathematical
Functions</B>:</LI>

<TABLE BORDER >
<TR>
<TD><B>ABS(X)</B></TD>

<TD>Absolute value-converts negative numbers to positive, or leaves positive
numbers alone</TD>
</TR>

<TR>
<TD><B>CEIL(X)</B></TD>

<TD>X is a decimal value that will be rounded up.</TD>
</TR>

<TR>
<TD><B>FLOOR(X)</B></TD>

<TD>X is a decimal value that will be rounded down.</TD>
</TR>

<TR>
<TD><B>GREATEST(X,Y)</B></TD>

<TD>Returns the largest of the two values.</TD>
</TR>

<TR>
<TD><B>LEAST(X,Y)</B></TD>

<TD>Returns the smallest of the two values.</TD>
</TR>

<TR>
<TD><B>MOD(X,Y)</B></TD>

<TD>Returns the remainder of X / Y.</TD>
</TR>

<TR>
<TD><B>POWER(X,Y)</B></TD>

<TD>Returns X to the power of Y.</TD>
</TR>

<TR>
<TD><B>ROUND(X,Y)</B></TD>

<TD>Rounds X to Y decimal places. If Y is omitted, X is rounded to the
nearest integer.</TD>
</TR>

<TR>
<TD><B>SIGN(X)</B></TD>

<TD>Returns a minus if X &lt; 0, else a plus.</TD>
</TR>

<TR>
<TD><B>SQRT(X)</B></TD>

<TD>Returns the square root of X.</TD>
</TR>
</TABLE>

<TABLE BORDER >
<CAPTION><B>Character Functions</B></CAPTION>

<TR>
<TD><B>LEFT(&lt;string>,X)</B></TD>

<TD>Returns the leftmost X characters of the string.</TD>
</TR>

<TR>
<TD><B>RIGHT(&lt;string>,X)</B></TD>

<TD>Returns the rightmost X characters of the string.</TD>
</TR>

<TR>
<TD><B>UPPER(&lt;string>)</B></TD>

<TD>Converts the string to all uppercase letters.</TD>
</TR>

<TR>
<TD><B>LOWER(&lt;string>)</B></TD>

<TD>Converts the string to all lowercase letters.</TD>
</TR>

<TR>
<TD><B>INITCAP(&lt;string>)</B></TD>

<TD>Converts the string to initial caps.</TD>
</TR>

<TR>
<TD><B>LENGTH(&lt;string>)</B></TD>

<TD>Returns the number of characters in the string.</TD>
</TR>

<TR>
<TD><B>&lt;string>||&lt;string></B></TD>

<TD>Combines the two strings of text into one, <I>concatenated</I> string,
where the first string is immediately followed by the second.</TD>
</TR>

<TR>
<TD><B>LPAD(&lt;string>,X,'*')</B></TD>

<TD>Pads the string on the left with the * (or whatever character is inside
the quotes), to make the string X characters long.</TD>
</TR>

<TR>
<TD><B>RPAD(&lt;string>,X,'*')</B></TD>

<TD>Pads the string on the right with the * (or whatever character is inside
the quotes), to make the string X characters long.</TD>
</TR>

<TR>
<TD><B>SUBSTR(&lt;string>,X,Y)</B></TD>

<TD>Extracts Y letters from the string beginning at position X.</TD>
</TR>

<TR>
<TD><B>NVL(&lt;column>,&lt;value>)</B></TD>

<TD>The Null value function will substitute &lt;value> for any NULLs for
in the &lt;column>. If the current value of &lt;column> is not NULL, NVL
has no effect.</TD>
</TR>
</TABLE>
</UL>

<HR WIDTH="100%"><A NAME="Syntax Summary"></A><B><FONT SIZE=+2>Syntax Summary--For
Advanced Users Only</FONT></B>
<P>Here are the general forms of the statements discussed in this tutorial,
plus some extra important ones (explanations given). <B>REMEMBER</B> that
all of these statements may or may not be available on your system, so
check documentation regarding availability:
<P><TT><B>ALTER TABLE </B>&lt;TABLE NAME> ADD|DROP|MODIFY (COLUMN SPECIFICATION[S]...see
Create Table); </TT>--allows you to add or delete a column or columns from
a table, or change the specification (data type, etc.) on an existing column;
this statement is also used to change the physical specifications of a
table (how a table is stored, etc.), but these definitions are DBMS-specific,
so read the documentation. Also, these physical specifications are used
with the Create Table statement, when a table is first created. In addition,
only one option can be performed per Alter Table statement--either add,
drop, <B>OR </B>modify in a single statement.
<P><TT><B>COMMIT</B>;</TT> --makes changes made to some database systems
permanent (since the last COMMIT; known as a <I>transaction</I>)
<P><TT><B>CREATE [UNIQUE] INDEX</B> &lt;INDEX NAME></TT>
<BR><TT>ON &lt;TABLE NAME> (&lt;COLUMN LIST>); </TT>--UNIQUE is optional;
within brackets.
<P><TT><B>CREATE TABLE</B> &lt;TABLE NAME></TT>
<BR><TT>(&lt;COLUMN NAME> &lt;DATA TYPE> [(&lt;SIZE>)] &lt;COLUMN CONSTRAINT>,</TT>
<BR><TT>...other columns); (</TT>also valid with ALTER TABLE)
<BR>--where SIZE is only used on certain data types (see above), and constraints
include the following possibilities (automatically enforced by the DBMS;
failure causes an error to be generated):
<OL>
<LI>
NULL or NOT NULL (see above)</LI>

<LI>
UNIQUE enforces that no two rows will have the same value for this column</LI>

<LI>
PRIMARY KEY tells the database that this column is the primary key column
(only used if the key is a one column key, otherwise a PRIMARY KEY (column,
column, ...) statement appears after the last column definition.</LI>

<LI>
CHECK allows a condition to be checked for when data in that column is
updated or inserted; for example, <TT>CHECK (PRICE > 0)</TT> causes the
system to check that the Price column is greater than zero before accepting
the value...sometimes implemented as the CONSTRAINT statement.</LI>

<LI>
DEFAULT inserts the default value into the database if a row is inserted
without that column's data being inserted; for example, <TT>BENEFITS INTEGER
DEFAULT = 10000</TT></LI>

<LI>
FOREIGN KEY works the same as Primary Key, but is followed by: <TT>REFERENCES
&lt;TABLE NAME> (&lt;COLUMN NAME>)</TT>, which refers to the referential
primary key.</LI>
</OL>
<TT><B>CREATE VIEW</B> &lt;TABLE NAME> AS &lt;QUERY>;</TT>
<P><TT><B>DELETE</B> FROM &lt;TABLE NAME> WHERE &lt;CONDITION>;</TT>
<P><TT><B>INSERT</B> INTO &lt;TABLE NAME> [(&lt;COLUMN LIST>)]</TT>
<BR><TT>VALUES (&lt;VALUE LIST>);</TT>
<P><TT><B>ROLLBACK</B>; </TT>--Takes back any changes to the database that
you have made, back to the last time you gave a Commit command...beware!
Some software uses automatic committing on systems that use the transaction
features, so the Rollback command may not work.
<P><TT><B>SELECT</B> [DISTINCT|ALL] &lt;LIST OF COLUMNS, FUNCTIONS, CONSTANTS,
ETC.></TT>
<BR><TT>FROM &lt;LIST OF TABLES OR VIEWS></TT>
<BR><TT>[WHERE &lt;CONDITION(S)>]</TT>
<BR><TT>[GROUP BY &lt;GROUPING COLUMN(S)>]</TT>
<BR><TT>[HAVING &lt;CONDITION>]</TT>
<BR><TT>[ORDER BY &lt;ORDERING COLUMN(S)> [ASC|DESC]]; </TT>--where ASC|DESC
allows the ordering to be done in ASCending or DESCending order
<P><TT><B>UPDATE</B> &lt;TABLE NAME></TT>
<BR><TT>SET &lt;COLUMN NAME> = &lt;VALUE></TT>
<BR><TT>[WHERE &lt;CONDITION>]; </TT>--if the Where clause is left out,
all rows will be updated according to the Set statement.
<HR WIDTH="100%"><A NAME="Important Links"></A><B>Important Computing &amp;
SQL/Database Links</B>
<P><A HREF="http://home.netscape.com">Netscape</A> -- <A HREF="http://www.oracle.com">Oracle</A>
-- <A HREF="http://www.sybase.com">Sybase</A> -- <A HREF="http://www.informix.com">Informix</A>
--<A HREF="http://www.microsoft.com">Microsoft</A>
<BR><A HREF="http://www.contrib.andrew.cmu.edu/~shadow/sql.html">SQL Reference
Page</A> -- <A HREF="http://www.inquiry.com/techtips/thesqlpro/">Ask the
SQL Pro</A> -- <A HREF="http://www.inquiry.com/techtips/thesqlpro/usefulsites.html">SQL
Pro's Relational DB Useful Sites</A>
<BR><A HREF="http://www.progsource.com/index.html">Programmer's Source</A>
-- <A HREF="http://info.itu.ch/special/wwwfiles/comp_db.html">DBMS Sites</A>
-- <A HREF="http://www.inquiry.com">inquiry.com</A> -- <A HREF="http://www.compapp.dcu.ie/databases/f017.html">DB
Ingredients</A> -- <A HREF="http://www.lizardfoot.com/SQLTrainer">SQL Trainer
S/W</A>
<BR><A HREF="http://www.stars.com/Tutorial/CGI/">Web Authoring</A> -- <A HREF="http://www-ccs.cs.umass.edu/db.html">DBMS
Lab/Links</A> -- <A HREF="http://epoch.CS.Berkeley.EDU:8000/sequoia/dba/montage/FAQ/SQL_TOC.html">SQL
FAQ</A> -- <A HREF="http://ashok.pair.com/sql.htm">Query List</A> -- <A HREF="http://www.tcx.se/">MySQL</A>
-- <A HREF="http://torresoft.netmegs.com">SQL Practice Site</A>
<BR><A HREF="http://www.pcslink.com/~ej/dbweb.html">Database Jump Site</A>
-- <A HREF="http://www.eng.uc.edu/~jtilley/tutorial.html">Programming Tutorials
on the Web</A> -- <A HREF="http://www.postgresql.org/">PostgreSQL</A> --
<A HREF="http://www.adobe.com/prodindex/acrobat/readstep.html">Adobe
Acrobat</A>
<BR><A HREF="http://thebestweb.com/db/sqlrefs.htm">DB Stuff</A> -- <A HREF="http://faculty.babson.edu/gordon/ispages/chapt7.htm">DBMS/IS
Pages</A> -- <A HREF="http://www.princeton.edu/~hannahk/WebPubl.htm">Access
on the Web</A> -- <A HREF="http://www.cs.ucsb.edu/~jingw/tutor.html">Online
Books</A> -- <A HREF="http://www.shelby.net/abotts/database.htm">A Good
DB Course</A>
<BR><A HREF="http://www.muppetlabs.com/library/tech/tutorials.html">Tutorial
Page</A> -- <A HREF="http://www.dbmsmag.com">DBMS Magazine</A> -- <A HREF="http://databases.miningco.com">Database
Mining</A> -- <A HREF="http://www.let.rug.nl/~s0367672/pm_int_e.htm">miniSQL</A>
-- <A HREF="http://www.softwareag.com/corporat/solutions/datamanage/adabasd/default.htm">Adabas<BR>
</A><A HREF="http://hometown.aol.com/rexxauthor/sqlbk.htm">SQL Book</A>
--&nbsp; <A HREF="http://msdn.microsoft.com/library/psdk/sql/8_gs_00.htm">SQL
Server 7</A> --&nbsp; <A HREF="http://www.vbscripts.com/sqlquickstart/">SQL
Quick Start</A> --&nbsp; <A HREF="http://users.neca.com/ltruett/sql.html">SQL
Reference/Examples</A> --&nbsp; <A HREF="http://www.sqlschool.org/">SQL
Topics</A>&nbsp;
<HR WIDTH="100%"><B>Disclaimer</B>
<P>I hope you have learned something from this introductory look at a very
important language that is becoming more prevalent in the world of client-server
computing. I wrote this web page in order to contribute something of value
to the web and the Internet community. In fact, I have been informed that
this document is being used at several colleges and companies for use in
database classes, and as a resource for many others. In addition, I would
like to thank all of the people from across five continents who have contacted
me regarding this web page.
<P>In addition, I strongly urge you to visit some of the database links
shown above, especially if you're interested in advanced topics, such as
the SQL-92 standard, different relational DBMS's, and advanced query processing.
Unfortunately, however, the number of database web sites remains small,
and if you are unable to find the information for which you are looking
at the links displayed above, the information may not be available on the
web, and that you will have to potentially contact a database vendor for
the information you seek. In fact, if you're using a well-known, name-brand
DBMS, the web site of your vendor is often the first and best place to
look for information.
<HR WIDTH="100%"><I>Supplemental files will no longer be available from
this site. I will not be able to distribute download files sent to me by
readers. In addition, I am not available for any consultations at this
time. Also, I will no longer be accepting questions via e-mail from readers.
The Algorithm tutorial has been removed, due to reader disinterest. If
you have a question or comment, please go to the new <A HREF="http://clubs.yahoo.com/clubs/structuredquerylanguage">Yahoo
SQL Club</A>.&nbsp; Also, due to a change in terms of service, I am taking
my page off of Geocities, back to its original site; sorry for any inconvenience.</I>
<P><A HREF="http://www.highcroft.com/highcroft/sql_intro.pdf">The PDF/Adobe
Acrobat version of the tutorial is available directly from Matthew Kelly
at Waterfront Communications (www.highcroft.com)...thanks again.</A>
<P><FONT SIZE=-1>Copyright 1996-1999, James Hoffman. This document can
be used for free by any Internet user, but cannot be included in another
document, another web site or server, published in any other form, or mass
produced in any way.</FONT>
<P><I>Last updated: 10-17-1999; added links (1,200 Yahoo! SQL Club members,
5th overall in Computers &amp; Internet clubs...297,500 hits; 2-26-99 thru
6-30-99).</I>
</BODY>
</HTML>
