# Tutorial: MySQL Ranking Functions

	1. MySQL offers several powerful 
	
	        ranking functions 
	        
	   that allow you to assign ranks 
	   to  rows  within a result set, 
	   based on specific criteria. 
	
	2. These functions are invaluable 
	   for tasks like 
	   
	     * leaderboards, 
	     * top-N analysis, 
	     * bottom-N,
	     * top-performers,
	     * bottom-performers,
	     * and more.
	
	
# 1. [Overview of SQL RANK functions by Rajendra Gupta](https://www.sqlshack.com/overview-of-sql-rank-functions/)


	
	
# 2. Practical Use Cases
* Leaderboards: Rank players or teams based on their performance.

* Top-N Analysis: Identify the top-performing products, customers, or employees.

* Sales Analysis: Rank sales representatives by their sales volume.

* Customer Segmentation: Rank customers based on their purchase frequency or total spending.

* Performance Evaluation: Rank employees based on their performance metrics.


# 3. Key Ranking Functions

##  RANK()
* Assigns a rank to each row within a partition, 
  **with gaps for ties**.
  
  | score | rank |
  |-------|------|
  |  10   |  1   |
  |  11   |  2   |
  |  11   |  2   |
  |  11   |  2   |
  |  16   |  5   |
  
* Syntax: 

~~~sql
RANK() OVER (PARTITION BY partition_column ORDER BY order_column ASC/DESC)
~~~

* Example-1:

~~~sql
SELECT product_name, 
       sales_amount,
       RANK() OVER (ORDER BY sales_amount DESC) 
         AS product_rank
FROM products;
~~~

* Example-2:

The `RANK()` function in MySQL assigns a rank to 
each row within a partition of a result set. The 
ranks **may have gaps if there are ties**. Here is 
an example demonstrating how to use the `RANK()` 
function with gaps for ties.

Suppose we have a table `employees` with the following 
schema and data:

```sql
CREATE TABLE employees (
    employee_id INT PRIMARY KEY,
    employee_name VARCHAR(100),
    salary DECIMAL(10, 2)
);

INSERT INTO employees (employee_id, employee_name, salary) 
VALUES
(1, 'Alice', 5000.00),
(2, 'Bob', 7000.00),
(3, 'Charlie', 7000.00),
(4, 'David', 6000.00),
(5, 'Eve', 8000.00);
```

We want to rank the employees based on their salaries. 
Employees with the same salary will have the same rank, 
but there will be gaps in the ranks if there are ties.

Here is the SQL query using the `RANK()` function:

```sql
SELECT 
    employee_id,
    employee_name,
    salary,
    RANK() OVER (ORDER BY salary DESC) AS rnk
FROM 
    employees;
```

### Explanation:
- `RANK() OVER (ORDER BY salary DESC)`: The `RANK()` 
  function assigns a rank to each row based on the 
  `salary` column in descending order. If two employees 
  have the same salary, they will receive the same rank, 
  but the next rank will have a gap.

### Result:
The result set will look like this:

```sql
+-------------+---------------+--------+------+
| employee_id | employee_name | salary | rnk  |
+-------------+---------------+--------+------+
|           5 | Eve           | 8000.00|    1 |
|           2 | Bob           | 7000.00|    2 |
|           3 | Charlie       | 7000.00|    2 |
|           4 | David         | 6000.00|    4 |
|           1 | Alice         | 5000.00|    5 |
+-------------+---------------+--------+------+
```

In this example, Bob and Charlie have the same salary 
and thus share the same rank of 2. The next rank after 
2 is 4, **creating a gap in the ranks** due to the tie.



## DENSE_RANK()
* Assigns a rank to each row within a partition, 
  **without gaps for ties**.
  
  | score | rank |
  |-------|------|
  |  10   |  1   |
  |  11   |  2   |
  |  11   |  2   |
  |  11   |  2   |
  |  16   |  3   |

* Syntax: 

~~~sql
DENSE_RANK() OVER (PARTITION BY partition_column ORDER BY order_column ASC/DESC)
~~~

* Example-1:

~~~sql
SELECT
employee_name,
salary,
DENSE_RANK() OVER (ORDER BY salary DESC) AS salary_rank
FROM employees;
~~~

* Example-2:

The `DENSE_RANK()` function in MySQL assigns a rank 
to each row within a partition of a result set. The 
**ranks do not have gaps** in the ranking sequence 
when there are ties.

Suppose we have a table `employees` with the following schema and data:

```sql
CREATE TABLE employees (
    employee_id INT PRIMARY KEY,
    employee_name VARCHAR(100),
    salary DECIMAL(10, 2)
);

INSERT INTO employees (employee_id, employee_name, salary) 
VALUES
(1, 'Alice', 5000.00),
(2, 'Bob', 7000.00),
(3, 'Charlie', 7000.00),
(4, 'David', 6000.00),
(5, 'Eve', 8000.00);
```

We want to rank the employees based on their 
salaries using `DENSE_RANK()`. Employees with 
the same salary will have the same rank, and 
there will be **no gaps in the ranks**.

Here is the SQL query using the `DENSE_RANK()` function:

```sql
SELECT 
    employee_id,
    employee_name,
    salary,
    DENSE_RANK() OVER (ORDER BY salary DESC) AS dense_rank
FROM 
    employees;
```

### Explanation:
- `DENSE_RANK() OVER (ORDER BY salary DESC)`: 
  The `DENSE_RANK()` function assigns a rank to 
  each row based on the `salary` column in descending 
  order. If two employees have the same salary, they 
  will receive the same rank, and there will be no 
  gaps in the ranks.

### Result:
The result set will look like this:

```sql
+-------------+---------------+--------+------------+
| employee_id | employee_name | salary | dense_rank |
+-------------+---------------+--------+------------+
|           5 | Eve           | 8000.00|          1 |
|           2 | Bob           | 7000.00|          2 |
|           3 | Charlie       | 7000.00|          2 |
|           4 | David         | 6000.00|          3 |
|           1 | Alice         | 5000.00|          4 |
+-------------+---------------+--------+------------+
```

In this example, Bob and Charlie have the same salary 
and thus share the same rank of 2. The next rank after 
2 is 3, with **no gaps in between**.


## ROW_NUMBER()
* Assigns a sequential number to each row within a 
  partition, starting from 1.
  
* Syntax: 

~~~sql
ROW_NUMBER() OVER (PARTITION BY partition_column ORDER BY order_column ASC/DESC)
~~~

* Example-1:

~~~sql
SELECT
order_id,
order_date,
ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY order_date ASC) AS order_number
FROM
orders;
~~~


* Example-2:

Here's an example of how to use the `ROW_NUMBER()` 
function in MySQL for ranking purposes.

Suppose we have a table `employees` with the following 
schema and data:

```sql
CREATE TABLE employees (
    employee_id INT PRIMARY KEY,
    employee_name VARCHAR(100),
    salary DECIMAL(10, 2)
);

INSERT INTO employees (employee_id, employee_name, salary) 
VALUES
(1, 'Alice', 5000.00),
(2, 'Bob', 7000.00),
(3, 'Charlie', 7000.00),
(4, 'David', 6000.00),
(5, 'Eve', 8000.00);
```

We want to rank the employees based on their salaries. 
The `ROW_NUMBER()` function can be used to assign a 
unique sequential integer to rows within the result set.

Here is the SQL query using the `ROW_NUMBER()` function:

```sql
SELECT 
    employee_id,
    employee_name,
    salary,
    ROW_NUMBER() OVER (ORDER BY salary DESC) AS row_num
FROM 
    employees;
```

### Explanation:
- `ROW_NUMBER() OVER (ORDER BY salary DESC)`: 
  The `ROW_NUMBER()` function assigns a unique 
  sequential integer to rows, starting with 1 
  for the first row in each partition. The 
  `ORDER BY salary DESC` clause specifies the 
  order in which the row numbers are assigned, 
  with the highest salary getting the row number 1.

### Result:
The result set will look like this:

```sql
+-------------+---------------+--------+---------+
| employee_id | employee_name | salary | row_num |
+-------------+---------------+--------+---------+
|           5 | Eve           | 8000.00|       1 |
|           2 | Bob           | 7000.00|       2 |
|           3 | Charlie       | 7000.00|       3 |
|           4 | David         | 6000.00|       4 |
|           1 | Alice         | 5000.00|       5 |
+-------------+---------------+--------+---------+
```

In this example, Eve has the highest salary 
and is assigned the row number 1, followed 
by Bob and Charlie with the same salary, and 
so on. Each row gets a unique row number.



## PERCENT_RANK()
* Calculates the percentile rank of each row within a partition.
* Syntax: 

~~~sql
PERCENT_RANK() OVER (PARTITION BY partition_column ORDER BY order_column ASC/DESC)
~~~

* Example-1:


~~~sql
SELECT
student_name,
score,
PERCENT_RANK() OVER (ORDER BY score DESC) AS percentile_rank
FROM
students;
~~~

* Example-2

Here is an example of how to use the `PERCENT_RANK()` 
function in MySQL. The `PERCENT_RANK()` function 
calculates the relative rank of a row within a 
partition of a result set, expressed as a percentage. 
**The result is a value between 0.00 and 1.00**.

Suppose we have a table `employees` with the following 
schema and data:

```sql
CREATE TABLE employees (
    employee_id INT PRIMARY KEY,
    employee_name VARCHAR(100),
    salary DECIMAL(10, 2)
);

INSERT INTO employees (employee_id, employee_name, salary) 
VALUES
(1, 'Alice', 5000.00),
(2, 'Bob', 7000.00),
(3, 'Charlie', 7000.00),
(4, 'David', 6000.00),
(5, 'Eve', 8000.00);
```

We want to calculate the percent rank of each 
employee based on their salary. Here is the SQL 
query using the `PERCENT_RANK()` function:

### PERCENT_RANK() ORDER ASC

```sql
SELECT 
    employee_id,
    employee_name,
    salary,
    PERCENT_RANK() OVER (ORDER BY salary DESC) AS percentage_rank
FROM 
    employees;
```

### Explanation:
- `PERCENT_RANK() OVER (ORDER BY salary DESC)`: 
  The `PERCENT_RANK()` function calculates the relative 
  rank of each row within the result set based on the 
  `salary` column in descending order.
- The result is a value between `0.00` and `1.00`, 
  inclusive, representing the percentage of rows that 
  are ranked lower than the current row.

### Result:
The result set will look like this:

```sql
+-------------+---------------+---------+-----------------+
| employee_id | employee_name | salary  | percentage_rank |
+-------------+---------------+---------+-----------------+
|           5 | Eve           | 8000.00 |               0 |
|           2 | Bob           | 7000.00 |            0.25 |
|           3 | Charlie       | 7000.00 |            0.25 |
|           4 | David         | 6000.00 |            0.75 |
|           1 | Alice         | 5000.00 |               1 |
+-------------+---------------+---------+-----------------+
5 rows in set (0.00 sec)
```

In this example:
- Eve has the highest salary and has a `percent_rank` of 0.0 (0%).
- Bob and Charlie have the same salary and share the same `percent_rank` of 0.25 (25%).
- David has a `percent_rank` of 0.75 (75%).
- Alice has the lowest salary and a `percent_rank` of 1.00 (100%).

### PERCENT_RANK() ORDER ASC
~~~sql
SELECT 
    employee_id,
    employee_name,
    salary,
    PERCENT_RANK() OVER (ORDER BY salary ASC) AS percentage_rank
FROM 
    employees;
+-------------+---------------+---------+-----------------+
| employee_id | employee_name | salary  | percentage_rank |
+-------------+---------------+---------+-----------------+
|           1 | Alice         | 5000.00 |               0 |
|           4 | David         | 6000.00 |            0.25 |
|           2 | Bob           | 7000.00 |             0.5 |
|           3 | Charlie       | 7000.00 |             0.5 |
|           5 | Eve           | 8000.00 |               1 |
+-------------+---------------+---------+-----------------+
5 rows in set (0.00 sec)
~~~

# 4. Additional Considerations

* Partitioning: Use the PARTITION BY clause to divide 
  the result set into smaller groups, applying the 
  ranking function to each group independently.

* Ordering: Use the ORDER BY clause to specify the 
  sorting order of the rows within each partition.

* Ties: Consider how you want to handle ties in the 
  ranking. The `RANK()` function leaves gaps for 
  ties, while `DENSE_RANK()` assigns consecutive 
  ranks to tied rows.

* By mastering these ranking functions, you can 
  gain deeper insights from your data and make more 
  informed decisions.

# 5. Example

~~~sql
create table sales (
  id int, 
  month  varchar(10),
  amount  int
);

insert into sales(id, month, amount)
values
     (1,'Jan',450),
     (2,'Jan',350),
     (3,'Jan',250),
     (4,'Feb',150),
     (5,'Feb',450),
     (6,'Feb',500),
     (7,'Mar',350),
     (8,'Mar',450),
     (9,'Mar',250),
     (10,'Mar',150);
~~~

Test table:

~~~sql
mysql> select * from sales;
+------+-------+--------+
| id   | month | amount |
+------+-------+--------+
|    1 | Jan   |    450 |
|    2 | Jan   |    350 |
|    3 | Jan   |    250 |
|    4 | Feb   |    150 |
|    5 | Feb   |    450 |
|    6 | Feb   |    500 |
|    7 | Mar   |    350 |
|    8 | Mar   |    450 |
|    9 | Mar   |    250 |
|   10 | Mar   |    150 |
+------+-------+--------+
~~~

Ranking:

	Here’s the query to assign rank to each row 
	of the table, without using any PARTITION BY clause.

~~~sql
SELECT
     id, month, amount, 
     RANK() OVER (PARTITION BY Month ORDER BY amount desc) as rank
FROM sales;

+------+-------+--------+--------+
| id   | month | amount |  rank  |
+------+-------+--------+--------+
|    6 | Feb   |    500 |     1  |
|    5 | Feb   |    450 |     2  |
|    4 | Feb   |    150 |     3  |
|    1 | Jan   |    450 |     1  |
|    2 | Jan   |    350 |     2  |
|    3 | Jan   |    250 |     3  |
|    8 | Mar   |    450 |     1  |
|    7 | Mar   |    350 |     2  |
|    9 | Mar   |    250 |     3  |
|   10 | Mar   |    150 |     4  |
+------+-------+--------+--------+
~~~

	In the above query, we partition the table 
	by month name, and then rank each row within 
	each partition in descending order of amount.


# Quick summary of SQL RANK Functions

### `ROW_Number`

	It assigns the sequential rank number 
	to each unique record.

### `RANK`

	It assigns the rank number to each row 
	in a partition. It skips the number for 
	similar values.

### `Dense_RANK`

	It assigns the rank number to each row 
	in a partition.  It does not  skip  the 
	number for similar values.


# Examples

## Table schema:

~~~sql
CREATE TABLE ExamResult
(name VARCHAR(70), 
 subject     VARCHAR(20), 
 marks       INT
);
~~~

## Table rows:

~~~sql
INSERT INTO ExamResult 
(name, subject, marks)
VALUES
('Lily', 'Math', 84),
('Lily', 'Science', 80),
('Lily', 'English', 70),
('Isabella', 'Math', 50),
('Isabella', 'Science', 70),
('Isabella', 'English', 90),
('Olivia', 'Math', 84),
('Olivia', 'Science', 60),
('Olivia', 'English', 89),
('Alex', 'Math', 84),
('Alex', 'Science', 67),
('Alex', 'English', 77),
('Alex', 'Music', 95);
~~~

## Examine Table:
~~~sql
select * from ExamResult order by name;
mysql> select * from ExamResult order by name;
+----------+---------+-------+
| name     | subject | marks |
+----------+---------+-------+
| Alex     | Math    |    84 |
| Alex     | Science |    67 |
| Alex     | English |    77 |
| Alex     | Music   |    95 |
| Isabella | Math    |    50 |
| Isabella | Science |    70 |
| Isabella | English |    90 |
| Lily     | Math    |    84 |
| Lily     | Science |    80 |
| Lily     | English |    70 |
| Olivia   | Math    |    84 |
| Olivia   | Science |    60 |
| Olivia   | English |    89 |
+----------+---------+-------+
13 rows in set (0.00 sec)
~~~

## ROW_NUMBER() ORDER ASC

~~~sql
SELECT 
    ROW_NUMBER() OVER (ORDER BY name) AS row_num,
    name,
    subject,
    marks
FROM 
    ExamResult
ORDER by name;

+---------+----------+---------+-------+
| row_num | name     | subject | marks |
+---------+----------+---------+-------+
|       1 | Alex     | Math    |    84 |
|       2 | Alex     | Science |    67 |
|       3 | Alex     | English |    77 |
|       4 | Alex     | Music   |    95 |
|       5 | Isabella | Math    |    50 |
|       6 | Isabella | Science |    70 |
|       7 | Isabella | English |    90 |
|       8 | Lily     | Math    |    84 |
|       9 | Lily     | Science |    80 |
|      10 | Lily     | English |    70 |
|      11 | Olivia   | Math    |    84 |
|      12 | Olivia   | Science |    60 |
|      13 | Olivia   | English |    89 |
+---------+----------+---------+-------+
13 rows in set (0.00 sec)
~~~

## ROW_NUMBER() ORDER DESC

~~~sql
SELECT 
    ROW_NUMBER() OVER (ORDER BY name DESC) AS row_num,
    name,
    subject,
    marks
FROM 
    ExamResult
ORDER by name;
+---------+----------+---------+-------+
| row_num | name     | subject | marks |
+---------+----------+---------+-------+
|      10 | Alex     | Math    |    84 |
|      11 | Alex     | Science |    67 |
|      12 | Alex     | English |    77 |
|      13 | Alex     | Music   |    95 |
|       7 | Isabella | Math    |    50 |
|       8 | Isabella | Science |    70 |
|       9 | Isabella | English |    90 |
|       4 | Lily     | Math    |    84 |
|       5 | Lily     | Science |    80 |
|       6 | Lily     | English |    70 |
|       1 | Olivia   | Math    |    84 |
|       2 | Olivia   | Science |    60 |
|       3 | Olivia   | English |    89 |
+---------+----------+---------+-------+
13 rows in set (0.00 sec)

~~~



## `ROW_Number()` SQL RANK function
We use `ROW_Number()` SQL RANK function to get 
a unique sequential number for each row in the 
specified data. It gives the rank one for the 
first row and then increments the value by one 
for each row. We get different ranks for the row 
having similar values as well.

Execute the following query to get a rank for 
students as per their marks.


### `ROW_NUMBER()` ORDER BY marks ASC
~~~sql
SELECT name, 
       subject, 
       marks, 
       ROW_NUMBER() OVER(ORDER BY marks ASC) RowNumber
FROM ExamResult;

+----------+---------+-------+-----------+
| name     | subject | marks | RowNumber |
+----------+---------+-------+-----------+
| Isabella | Math    |    50 |         1 |
| Olivia   | Science |    60 |         2 |
| Alex     | Science |    67 |         3 |
| Lily     | English |    70 |         4 |
| Isabella | Science |    70 |         5 |
| Alex     | English |    77 |         6 |
| Lily     | Science |    80 |         7 |
| Lily     | Math    |    84 |         8 |
| Olivia   | Math    |    84 |         9 |
| Alex     | Math    |    84 |        10 |
| Olivia   | English |    89 |        11 |
| Isabella | English |    90 |        12 |
| Alex     | Music   |    95 |        13 |
+----------+---------+-------+-----------+
13 rows in set (0.00 sec)
~~~

### `ROW_NUMBER()` ORDER BY marks DESC
~~~sql
SELECT name, 
       subject, 
       marks, 
       ROW_NUMBER() OVER(ORDER BY marks DESC) RowNumber
FROM ExamResult;

+----------+---------+-------+-----------+
| name     | subject | marks | RowNumber |
+----------+---------+-------+-----------+
| Alex     | Music   |    95 |         1 |
| Isabella | English |    90 |         2 |
| Olivia   | English |    89 |         3 |
| Lily     | Math    |    84 |         4 |
| Olivia   | Math    |    84 |         5 |
| Alex     | Math    |    84 |         6 |
| Lily     | Science |    80 |         7 |
| Alex     | English |    77 |         8 |
| Lily     | English |    70 |         9 |
| Isabella | Science |    70 |        10 |
| Alex     | Science |    67 |        11 |
| Olivia   | Science |    60 |        12 |
| Isabella | Math    |    50 |        13 |
+----------+---------+-------+-----------+
13 rows in set (0.00 sec)
~~~



## `RANK()` SQL RANK Function
We use `RANK()` SQL Rank function to specify 
rank for each row in the result set. We have 
student results for three subjects. We want 
to rank the result of students as per their 
marks in the subjects. 

### `RANK()` ORDER DESC
~~~sql
SELECT name, 
       subject, 
       marks, 
       RANK() OVER(ORDER BY marks DESC) rnk
FROM ExamResult
ORDER BY rnk;

+----------+---------+-------+-----+
| name     | subject | marks | rnk |
+----------+---------+-------+-----+
| Alex     | Music   |    95 |   1 |
| Isabella | English |    90 |   2 |
| Olivia   | English |    89 |   3 |
| Lily     | Math    |    84 |   4 |
| Olivia   | Math    |    84 |   4 |
| Alex     | Math    |    84 |   4 |
| Lily     | Science |    80 |   7 |
| Alex     | English |    77 |   8 |
| Lily     | English |    70 |   9 |
| Isabella | Science |    70 |   9 |
| Alex     | Science |    67 |  11 |
| Olivia   | Science |    60 |  12 |
| Isabella | Math    |    50 |  13 |
+----------+---------+-------+-----+
13 rows in set (0.00 sec)
~~~

----

### `RANK()` ORDER ASC
~~~sql
SELECT name, 
       subject, 
       marks, 
       RANK() OVER(ORDER BY marks ASC) rnk
FROM ExamResult
ORDER BY rnk;

+----------+---------+-------+-----+
| name     | subject | marks | rnk |
+----------+---------+-------+-----+
| Isabella | Math    |    50 |   1 |
| Olivia   | Science |    60 |   2 |
| Alex     | Science |    67 |   3 |
| Lily     | English |    70 |   4 |
| Isabella | Science |    70 |   4 |
| Alex     | English |    77 |   6 |
| Lily     | Science |    80 |   7 |
| Lily     | Math    |    84 |   8 |
| Olivia   | Math    |    84 |   8 |
| Alex     | Math    |    84 |   8 |
| Olivia   | English |    89 |  11 |
| Isabella | English |    90 |  12 |
| Alex     | Music   |    95 |  13 |
+----------+---------+-------+-----+
13 rows in set (0.00 sec)
~~~

-----

### `RANK()` OVER(PARTITION... ORDER DESC)

~~~sql
SELECT name, 
       subject, 
       marks, 
       RANK() OVER(PARTITION BY name ORDER BY marks DESC) rnk
FROM ExamResult
ORDER BY name, rnk;
+----------+---------+-------+-----+
| name     | subject | marks | rnk |
+----------+---------+-------+-----+
| Alex     | Music   |    95 |   1 |
| Alex     | Math    |    84 |   2 |
| Alex     | English |    77 |   3 |
| Alex     | Science |    67 |   4 |
| Isabella | English |    90 |   1 |
| Isabella | Science |    70 |   2 |
| Isabella | Math    |    50 |   3 |
| Lily     | Math    |    84 |   1 |
| Lily     | Science |    80 |   2 |
| Lily     | English |    70 |   3 |
| Olivia   | English |    89 |   1 |
| Olivia   | Math    |    84 |   2 |
| Olivia   | Science |    60 |   3 |
+----------+---------+-------+-----+
13 rows in set (0.00 sec)
~~~

-----

~~~sql
SELECT name, 
       subject, 
       marks, 
       RANK() OVER(PARTITION BY subject ORDER BY marks DESC) rnk
FROM ExamResult
ORDER BY subject, rnk;
+----------+---------+-------+-----+
| name     | subject | marks | rnk |
+----------+---------+-------+-----+
| Isabella | English |    90 |   1 |
| Olivia   | English |    89 |   2 |
| Alex     | English |    77 |   3 |
| Lily     | English |    70 |   4 |
| Lily     | Math    |    84 |   1 |
| Olivia   | Math    |    84 |   1 |
| Alex     | Math    |    84 |   1 |
| Isabella | Math    |    50 |   4 |
| Alex     | Music   |    95 |   1 |
| Lily     | Science |    80 |   1 |
| Isabella | Science |    70 |   2 |
| Alex     | Science |    67 |   3 |
| Olivia   | Science |    60 |   4 |
+----------+---------+-------+-----+
13 rows in set (0.00 sec)
~~~

------


### `RANK()` OVER(PARTITION... ORDER ASC)
~~~sql
SELECT name, 
       subject, 
       marks, 
       RANK() OVER(PARTITION BY name ORDER BY marks ASC) rnk
FROM ExamResult
ORDER BY name, rnk;

+----------+---------+-------+-----+
| name     | subject | marks | rnk |
+----------+---------+-------+-----+
| Alex     | Science |    67 |   1 |
| Alex     | English |    77 |   2 |
| Alex     | Math    |    84 |   3 |
| Alex     | Music   |    95 |   4 |
| Isabella | Math    |    50 |   1 |
| Isabella | Science |    70 |   2 |
| Isabella | English |    90 |   3 |
| Lily     | English |    70 |   1 |
| Lily     | Science |    80 |   2 |
| Lily     | Math    |    84 |   3 |
| Olivia   | Science |    60 |   1 |
| Olivia   | Math    |    84 |   2 |
| Olivia   | English |    89 |   3 |
+----------+---------+-------+-----+
13 rows in set (0.00 sec)
~~~

-----


## `DENSE_RANK()` SQL RANK function

We use `DENSE_RANK()` function to specify a 
unique rank number within the partition as 
per the specified column value. It is similar 
to the `RANK()` function with a small difference.

In the SQL RANK function `DENSE_RANK()`, if we 
have duplicate values, SQL assigns different ranks 
to those rows as well. Ideally, we should get the 
same rank for duplicate or similar values.

Let’s execute the following query with the 
`DENSE_RANK()` function.

~~~sql
SELECT name, 
       subject, 
       marks, 
       DENSE_RANK() OVER(ORDER BY marks DESC) rnk
FROM ExamResult
ORDER BY rnk;
+----------+---------+-------+-----+
| name     | subject | marks | rnk |
+----------+---------+-------+-----+
| Alex     | Music   |    95 |   1 |
| Isabella | English |    90 |   2 |
| Olivia   | English |    89 |   3 |
| Lily     | Math    |    84 |   4 |
| Olivia   | Math    |    84 |   4 |
| Alex     | Math    |    84 |   4 |
| Lily     | Science |    80 |   5 |
| Alex     | English |    77 |   6 |
| Lily     | English |    70 |   7 |
| Isabella | Science |    70 |   7 |
| Alex     | Science |    67 |   8 |
| Olivia   | Science |    60 |   9 |
| Isabella | Math    |    50 |  10 |
+----------+---------+-------+-----+
13 rows in set (0.00 sec)
~~~

-----

~~~sql
SELECT name, 
       subject, 
       marks, 
       DENSE_RANK() OVER(PARTITION BY subject ORDER BY marks DESC) rnk
FROM ExamResult
ORDER BY rnk;
+----------+---------+-------+-----+
| name     | subject | marks | rnk |
+----------+---------+-------+-----+
| Isabella | English |    90 |   1 |
| Lily     | Math    |    84 |   1 |
| Olivia   | Math    |    84 |   1 |
| Alex     | Math    |    84 |   1 |
| Alex     | Music   |    95 |   1 |
| Lily     | Science |    80 |   1 |
| Olivia   | English |    89 |   2 |
| Isabella | Math    |    50 |   2 |
| Isabella | Science |    70 |   2 |
| Alex     | English |    77 |   3 |
| Alex     | Science |    67 |   3 |
| Lily     | English |    70 |   4 |
| Olivia   | Science |    60 |   4 |
+----------+---------+-------+-----+
13 rows in set (0.00 sec)
~~~

-----

~~~sql
SELECT name, 
       subject, 
       marks, 
       DENSE_RANK() OVER(PARTITION BY subject ORDER BY marks DESC) rnk
FROM ExamResult
ORDER BY subject, rnk;
+----------+---------+-------+-----+
| name     | subject | marks | rnk |
+----------+---------+-------+-----+
| Isabella | English |    90 |   1 |
| Olivia   | English |    89 |   2 |
| Alex     | English |    77 |   3 |
| Lily     | English |    70 |   4 |
| Lily     | Math    |    84 |   1 |
| Olivia   | Math    |    84 |   1 |
| Alex     | Math    |    84 |   1 |
| Isabella | Math    |    50 |   2 |
| Alex     | Music   |    95 |   1 |
| Lily     | Science |    80 |   1 |
| Isabella | Science |    70 |   2 |
| Alex     | Science |    67 |   3 |
| Olivia   | Science |    60 |   4 |
+----------+---------+-------+-----+
13 rows in set (0.00 sec)
~~~

-----

~~~sql
SELECT name, 
       subject, 
       marks, 
       DENSE_RANK() OVER(PARTITION BY subject ORDER BY marks DESC) rnk
FROM ExamResult
ORDER BY name, rnk;
+----------+---------+-------+-----+
| name     | subject | marks | rnk |
+----------+---------+-------+-----+
| Alex     | Math    |    84 |   1 |
| Alex     | Music   |    95 |   1 |
| Alex     | English |    77 |   3 |
| Alex     | Science |    67 |   3 |
| Isabella | English |    90 |   1 |
| Isabella | Math    |    50 |   2 |
| Isabella | Science |    70 |   2 |
| Lily     | Math    |    84 |   1 |
| Lily     | Science |    80 |   1 |
| Lily     | English |    70 |   4 |
| Olivia   | Math    |    84 |   1 |
| Olivia   | English |    89 |   2 |
| Olivia   | Science |    60 |   4 |
+----------+---------+-------+-----+
13 rows in set (0.00 sec)
~~~

## Difference between `RANK()` and `DENSE_RANK()` 
Let’s see the difference between `RANK()` 
and `DENSE_RANK()` SQL Rank function with 
the following queries: `Query 1` and `Query 2`.

~~~sql
-- Query 1
SELECT name, subject, marks, 
       RANK() OVER(PARTITION BY name ORDER BY marks) rnk
FROM ExamResult
ORDER BY name, rnk;

-- Query 2
SELECT name, subject, marks,
       DENSE_RANK() OVER(PARTITION BY name ORDER BY marks) rnk
FROM ExamResult
ORDER BY name, rnk;
~~~


### Query 1
~~~sql
SELECT name, subject, marks, 
       RANK() OVER(PARTITION BY name ORDER BY marks) rnk
FROM ExamResult
ORDER BY name, rnk;
+----------+---------+-------+-----+
| name     | subject | marks | rnk |
+----------+---------+-------+-----+
| Alex     | Science |    67 |   1 |
| Alex     | English |    77 |   2 |
| Alex     | Math    |    84 |   3 |
| Alex     | Music   |    95 |   4 |
| Isabella | Math    |    50 |   1 |
| Isabella | Science |    70 |   2 |
| Isabella | English |    90 |   3 |
| Lily     | English |    70 |   1 |
| Lily     | Science |    80 |   2 |
| Lily     | Math    |    84 |   3 |
| Olivia   | Science |    60 |   1 |
| Olivia   | Math    |    84 |   2 |
| Olivia   | English |    89 |   3 |
+----------+---------+-------+-----+
13 rows in set (0.01 sec)
~~~

### Query 2
~~~sql
SELECT name, subject, marks,
       DENSE_RANK() OVER(PARTITION BY name ORDER BY marks ) rnk
FROM ExamResult
ORDER BY name, rnk;
+----------+---------+-------+-----+
| name     | subject | marks | rnk |
+----------+---------+-------+-----+
| Alex     | Science |    67 |   1 |
| Alex     | English |    77 |   2 |
| Alex     | Math    |    84 |   3 |
| Alex     | Music   |    95 |   4 |
| Isabella | Math    |    50 |   1 |
| Isabella | Science |    70 |   2 |
| Isabella | English |    90 |   3 |
| Lily     | English |    70 |   1 |
| Lily     | Science |    80 |   2 |
| Lily     | Math    |    84 |   3 |
| Olivia   | Science |    60 |   1 |
| Olivia   | Math    |    84 |   2 |
| Olivia   | English |    89 |   3 |
+----------+---------+-------+-----+
13 rows in set (0.00 sec)
~~~

----


## Practical Usage of SQL RANK functions
We can use SQL RANK function to fetch specific 
rows from the data. Suppose we want to get the 
data of the students from ranks 1 to 3. In the 
following query, we use common table expressions
(CTE) to get data using `ROW_NUMBER()` function 
and later filtered the result from CTE to satisfy 
our condition.

~~~sql
WITH StudentRanks AS
(
  SELECT name, subject, marks, 
         ROW_NUMBER() OVER( ORDER BY marks) AS rnk
  FROM ExamResult
)
SELECT name , subject, marks, rnk
FROM StudentRanks
WHERE rnk >= 1 and rnk <=2
ORDER BY rnk;
+----------+---------+-------+-----+
| name     | subject | marks | rnk |
+----------+---------+-------+-----+
| Isabella | Math    |    50 |   1 |
| Olivia   | Science |    60 |   2 |
+----------+---------+-------+-----+
2 rows in set (0.00 sec)
~~~

-----

~~~sql
WITH StudentRanks AS
(
  SELECT name, subject, marks, 
         ROW_NUMBER() OVER( ORDER BY marks DESC) AS rnk
  FROM ExamResult
)
SELECT name , subject, marks, rnk
FROM StudentRanks
WHERE rnk >= 1 and rnk <=2
ORDER BY rnk;
+----------+---------+-------+-----+
| name     | subject | marks | rnk |
+----------+---------+-------+-----+
| Alex     | Music   |    95 |   1 |
| Isabella | English |    90 |   2 |
+----------+---------+-------+-----+
2 rows in set (0.01 sec)
~~~

----

~~~sql
WITH StudentRanks AS
(
  SELECT name, subject, marks, 
         ROW_NUMBER() OVER(PARTITION BY subject ORDER BY marks) AS rnk
  FROM ExamResult
)
SELECT name , subject, marks, rnk
FROM StudentRanks
WHERE rnk >= 1 and rnk <=2
ORDER BY rnk;
+----------+---------+-------+-----+
| name     | subject | marks | rnk |
+----------+---------+-------+-----+
| Lily     | English |    70 |   1 |
| Isabella | Math    |    50 |   1 |
| Alex     | Music   |    95 |   1 |
| Olivia   | Science |    60 |   1 |
| Alex     | English |    77 |   2 |
| Lily     | Math    |    84 |   2 |
| Alex     | Science |    67 |   2 |
+----------+---------+-------+-----+
7 rows in set (0.00 sec)
~~~

-----

~~~sql
WITH StudentRanks AS
(
  SELECT name, subject, marks, 
         ROW_NUMBER() OVER(PARTITION BY subject ORDER BY marks DESC) AS rnk
  FROM ExamResult
)
SELECT name , subject, marks, rnk
FROM StudentRanks
WHERE rnk >= 1 and rnk <=2
ORDER BY rnk;
+----------+---------+-------+-----+
| name     | subject | marks | rnk |
+----------+---------+-------+-----+
| Isabella | English |    90 |   1 |
| Lily     | Math    |    84 |   1 |
| Alex     | Music   |    95 |   1 |
| Lily     | Science |    80 |   1 |
| Olivia   | English |    89 |   2 |
| Olivia   | Math    |    84 |   2 |
| Isabella | Science |    70 |   2 |
+----------+---------+-------+-----+
7 rows in set (0.00 sec)
~~~

-----

~~~sql
WITH StudentRanks AS
(
  SELECT *, 
         ROW_NUMBER() OVER( ORDER BY marks) AS rnk
  FROM ExamResult
)
SELECT name , subject, marks, rnk 
FROM StudentRanks
ORDER BY rnk 
LIMIT 3;
+----------+---------+-------+-----+
| name     | subject | marks | rnk |
+----------+---------+-------+-----+
| Isabella | Math    |    50 |   1 |
| Olivia   | Science |    60 |   2 |
| Alex     | Science |    67 |   3 |
+----------+---------+-------+-----+
3 rows in set (0.00 sec)
~~~

----

~~~sql
WITH StudentRanks AS
(
  SELECT *, 
         ROW_NUMBER() OVER( ORDER BY marks DESC) AS rnk
  FROM ExamResult
)
SELECT name , subject, marks, rnk 
FROM StudentRanks
ORDER BY rnk 
LIMIT 3;
+----------+---------+-------+-----+
| name     | subject | marks | rnk |
+----------+---------+-------+-----+
| Alex     | Music   |    95 |   1 |
| Isabella | English |    90 |   2 |
| Olivia   | English |    89 |   3 |
+----------+---------+-------+-----+
3 rows in set (0.00 sec)
~~~


## 6 OLAP queries using `RANK()`, `CTE`, sub-queries, and joins on the `ExamResult` table:

**Query 1**: Uses a CTE to calculate the total 
   marks for each student and ranks them based on 
   their total marks.

```sql
-- Query 1: Rank students based on their total marks 
-- across all subjects using RANK()
WITH TotalMarks AS (
    SELECT 
        name,
        SUM(marks) AS total_marks
    FROM 
        ExamResult
    GROUP BY 
        name
)
SELECT 
    name,
    total_marks,
    RANK() OVER (ORDER BY total_marks DESC) AS rnk
FROM 
    TotalMarks;
+----------+-------------+-----+
| name     | total_marks | rnk |
+----------+-------------+-----+
| Alex     |         323 |   1 |
| Lily     |         234 |   2 |
| Olivia   |         233 |   3 |
| Isabella |         210 |   4 |
+----------+-------------+-----+
4 rows in set (0.00 sec)
```

**Query 2**: Uses a CTE to rank students in each 
   subject based on their marks and selects the top 2 
   students per subject.

~~~sql  
-- Query 2: Find the top 2 students in each subject using RANK()
WITH SubjectRanks AS (
    SELECT 
        name, subject, marks,
        RANK() OVER (PARTITION BY subject ORDER BY marks DESC) AS rnk
    FROM 
        ExamResult
)
SELECT 
    name, subject, marks, rnk
FROM 
    SubjectRanks
WHERE 
    rnk <= 2;
+----------+---------+-------+-----+
| name     | subject | marks | rnk |
+----------+---------+-------+-----+
| Isabella | English |    90 |   1 |
| Olivia   | English |    89 |   2 |
| Lily     | Math    |    84 |   1 |
| Olivia   | Math    |    84 |   1 |
| Alex     | Math    |    84 |   1 |
| Alex     | Music   |    95 |   1 |
| Lily     | Science |    80 |   1 |
| Isabella | Science |    70 |   2 |
+----------+---------+-------+-----+
8 rows in set (0.00 sec)
~~~

**Query 3**: Uses nested CTEs to calculate 
   the average marks per subject and rank students 
   based on their marks in each subject.

~~~sql
-- Query 3: Calculate the average marks per subject 
-- and rank students based on their marks in each subject
WITH SubjectAverages AS (
    SELECT 
        subject,
        AVG(marks) AS avg_marks
    FROM 
        ExamResult
    GROUP BY subject
), 
SubjectRanks AS (
    SELECT 
        er.name, er.subject, er.marks,
        sa.avg_marks,
        RANK() OVER (PARTITION BY er.subject ORDER BY er.marks DESC) AS rnk
    FROM 
        ExamResult er
    JOIN 
        SubjectAverages sa ON er.subject = sa.subject
)
SELECT 
    name, subject, marks, avg_marks, rnk
FROM 
    SubjectRanks;
+----------+---------+-------+-----------+-----+
| name     | subject | marks | avg_marks | rnk |
+----------+---------+-------+-----------+-----+
| Isabella | English |    90 |   81.5000 |   1 |
| Olivia   | English |    89 |   81.5000 |   2 |
| Alex     | English |    77 |   81.5000 |   3 |
| Lily     | English |    70 |   81.5000 |   4 |
| Lily     | Math    |    84 |   75.5000 |   1 |
| Olivia   | Math    |    84 |   75.5000 |   1 |
| Alex     | Math    |    84 |   75.5000 |   1 |
| Isabella | Math    |    50 |   75.5000 |   4 |
| Alex     | Music   |    95 |   95.0000 |   1 |
| Lily     | Science |    80 |   69.2500 |   1 |
| Isabella | Science |    70 |   69.2500 |   2 |
| Alex     | Science |    67 |   69.2500 |   3 |
| Olivia   | Science |    60 |   69.2500 |   4 |
+----------+---------+-------+-----------+-----+
13 rows in set (0.01 sec)
~~~

**Query 4**: Uses a CTE to calculate the average marks 
   per subject and counts the number of students who scored 
   above the average in each subject.

~~~sql
-- Query 4: Find the number of students who scored 
-- above the average marks in each subject
WITH SubjectAverages AS (
    SELECT 
        subject,
        AVG(marks) AS avg_marks
    FROM 
        ExamResult
    GROUP BY subject
)
SELECT 
    er.subject,
    COUNT(*) AS above_avg_count
FROM 
    ExamResult er
JOIN 
    SubjectAverages sa ON er.subject = sa.subject
WHERE 
    er.marks > sa.avg_marks
GROUP BY 
    er.subject;
+---------+-----------------+
| subject | above_avg_count |
+---------+-----------------+
| Math    |               3 |
| Science |               2 |
| English |               2 |
+---------+-----------------+
3 rows in set (0.00 sec)
~~~

**Query 5**: Uses aggregate functions in a simple query 
   to find the highest and lowest marks in each subject.

~~~sql
-- Query 5: Find the highest and lowest marks in 
-- each subject using sub-queries
SELECT 
    subject,
    MAX(marks) AS highest_marks,
    MIN(marks) AS lowest_marks
FROM 
    ExamResult
GROUP BY 
    subject;
+---------+---------------+--------------+
| subject | highest_marks | lowest_marks |
+---------+---------------+--------------+
| Math    |            84 |           50 |
| Science |            80 |           60 |
| English |            90 |           70 |
| Music   |            95 |           95 |
+---------+---------------+--------------+
4 rows in set (0.00 sec)
~~~

**Query 6**: Uses a CTE to find the maximum marks 
   in each subject and lists students who have scored 
   the highest marks in at least one subject.

~~~sql
-- Query 6: List students who have scored 
-- the highest marks in at least one subject
WITH MaxMarks AS (
    SELECT 
        subject,
        MAX(marks) AS max_marks
    FROM ExamResult
    GROUP BY subject
)
SELECT 
    DISTINCT er.name, er.subject
FROM 
    ExamResult er
JOIN 
    MaxMarks mm ON er.subject = mm.subject AND 
    er.marks = mm.max_marks;
+----------+---------+
| name     | subject |
+----------+---------+
| Lily     | Math    |
| Lily     | Science |
| Isabella | English |
| Olivia   | Math    |
| Alex     | Math    |
| Alex     | Music   |
+----------+---------+
6 rows in set (0.00 sec)
~~~




